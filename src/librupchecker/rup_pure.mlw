module Rup

use array.Array
use mach.int.Int63
use list.Append
use list.Elements
use list.HdTl
use list.Length
use list.List
use list.Map
use list.Mem
use list.Reverse
use map.Map as Map
use option.Option
use ref.Ref

(****************************************************************************
* Primary definitions
*****************************************************************************)

type var = int63
type lit = { var : var ; sign : bool }
type clause = list lit
type cnf = list clause
type valuation = Map.map var bool
type chain = list lit
type proof = list clause

let function negate (l : lit) : lit =
    { var = l.var ; sign = not l.sign }

predicate negated (l : lit) (l' : lit) =
    l' = negate l

predicate clause_sat_with (rho : valuation) (c : clause) =
    exists l . mem l c /\ Map.get rho l.var = l.sign

predicate cnf_sat_with (rho : valuation) (cnf : cnf) =
    forall c . mem c cnf -> clause_sat_with rho c

predicate clause_trivial (c : clause) =
    exists l . mem l c /\ mem (negate l) c

predicate no_trivial_clauses (cnf : cnf) =
    forall c . mem c cnf -> not (clause_trivial c)

predicate clause_redundant (c : clause) =
    match c with
    | Nil -> false
    | Cons l ls -> mem l ls \/ clause_redundant ls
    end

predicate no_redundant_clauses (cnf : cnf) =
    forall c . mem c cnf -> not (clause_redundant c)

predicate clause_unit (c : clause) =
    exists l . c = Cons l Nil

predicate is_unit (l : lit) (cnf : cnf) =
    mem (Cons l Nil) cnf

predicate cnf_sat (cnf : cnf) =
    exists rho . cnf_sat_with rho cnf

predicate cnf_unsat (cnf : cnf) =
    not (cnf_sat cnf)

function clause_lits (c : clause) : Fset.fset lit =
    match c with
    | Nil -> Fset.empty
    | Cons l c' -> Fset.add l (clause_lits c')
    end

let rec lemma clause_lits_mem (c : clause) (l : lit) =
    ensures { Fset.mem l (clause_lits c) <-> mem l c }
    variant { c }
    match c with
    | Nil -> ()
    | Cons _ c' -> clause_lits_mem c' l
    end

function cnf_lits (cnf : cnf) : Fset.fset lit =
    match cnf with
    | Nil -> Fset.empty
    | Cons c cs -> Fset.union (clause_lits c) (cnf_lits cs)
    end

let rec lemma cnf_lits_mem (cnf : cnf) (l : lit) =
    ensures { Fset.mem l (cnf_lits cnf) <-> exists c . mem c cnf /\ mem l c }
    variant { cnf }
    match cnf with
    | Nil -> ()
    | Cons _ cs -> cnf_lits_mem cs l
    end

let rec function remove_redundant_lits (c : clause) : clause =
    ensures { not (clause_redundant result) }
    ensures { forall l . mem l c <-> mem l result }
    ensures { forall rho . clause_sat_with rho c <-> clause_sat_with rho result }
    ensures { not (clause_redundant c) -> result = c}
    let predicate (==) (x y : bool) : bool =
        (x && y) || (not x && not y)
    in
    let predicate lit_eq (l1 l2 : lit) =
        ensures { result <-> l1.var = l2.var && l1.sign = l2.sign }
        l1.var = l2.var && l1.sign == l2.sign
    in
    let rec function do_mem (x : lit) (xs : list lit) (eq : lit -> lit -> bool) : bool =
        requires { forall y . eq x y <-> x = y }
        ensures { result = mem x xs }
        match xs with
        | Nil -> false
        | Cons y ys -> (eq x y) || do_mem x ys eq
        end	
    in
    match c with
    | Nil -> Nil
    | Cons l ls -> 
        if do_mem l ls lit_eq then remove_redundant_lits ls
        else Cons l (remove_redundant_lits ls)
    end

lemma empty_clause_unsat : forall rho .
    not (clause_sat_with rho Nil)

lemma conflict_cnf_unsat : forall cnf .
    mem Nil cnf -> cnf_unsat cnf

lemma empty_cnf_sat : forall rho .
    cnf_sat_with rho Nil

function remove_lit (l : lit) (c : clause) : clause =
    match c with
    | Nil -> Nil
    | Cons l' ls ->
        if l.var = l'.var /\ l.sign = l'.sign then ls
        else Cons l' (remove_lit l ls)
    end

let rec lemma remove_lit_mem (l l' : lit) (c : clause) =
    requires { not (clause_redundant c) }
    ensures { mem l' (remove_lit l c) <-> (l'.var <> l.var \/ l'.sign <> l.sign) /\ mem l' c }
    ensures { mem l' (remove_lit l c) <-> l' <> l /\ mem l' c }
    ensures { not (mem l c) <-> remove_lit l c = c }
    variant { c }
    match c with
    | Nil -> ()
    | Cons _ ms -> remove_lit_mem l l' ms
    end

let rec lemma remove_lit_noneg (l : lit) (c : clause) =
    requires { not (clause_redundant c) }
    ensures { not (mem (negate l) (remove_lit (negate l) c)) }
    variant { c }
    match c with
    | Nil -> ()
    | Cons _ ms -> remove_lit_noneg l ms
    end

let rec lemma remove_lit_twice (l l' : lit) (c : clause) =
    requires { not (clause_redundant c) }
    requires { l <> l' /\ l <> negate l' }
    ensures { remove_lit l (remove_lit l' c) = remove_lit l' (remove_lit l c) }
    variant { c }
    match c with
    | Nil -> ()
    | Cons _ ms -> remove_lit_twice l l' ms
    end

let rec lemma remove_lit_nil (l : lit) (c : clause) =
    requires { not (clause_redundant c) }
    ensures { remove_lit l c = Nil <-> (c = Cons l Nil \/ c = Nil) }
    variant { c }
    match c with
    | Nil -> ()
    | Cons _ ms -> remove_lit_nil l ms
    end

function remove_containing_lit (l : lit) (cnf : cnf) : cnf =
    match cnf with
    | Nil -> Nil
    | Cons c cs -> 
        if mem l c then remove_containing_lit l cs
        else Cons c (remove_containing_lit l cs)
    end

let rec lemma rc_nolit (l : lit) (cnf : cnf) (c : clause) =
    requires { mem c (remove_containing_lit l cnf) }
    ensures { not (mem l c) }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons _ cs ->
        if mem c (remove_containing_lit l cs) then rc_nolit l cs c
        else ()
    end

let rec lemma rc_subset (l : lit) (cnf : cnf) (c : clause) =
    requires { mem c (remove_containing_lit l cnf) }
    ensures { mem c cnf }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons _ cs -> 
        if mem c (remove_containing_lit l cs) then rc_subset l cs c
        else ()
    end

let rec lemma rc_contains (l : lit) (cnf : cnf) (c : clause) =
    requires { mem c cnf }
    requires { not (mem l c) }
    ensures { mem c (remove_containing_lit l cnf) }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons _ cs -> 
        if mem c cs then rc_contains l cs c
        else ()
    end

let rec lemma rl_mem (l : lit) (cnf : cnf) (c : clause) =
    requires { mem c (map (fun x -> remove_lit (negate l) x) cnf) }
    ensures { exists c' . mem c' cnf /\ c = remove_lit (negate l) c' }
    variant { cnf }
    match cnf with
    | Nil -> ()
    | Cons _ ds ->
        if mem c (map (fun x -> remove_lit (negate l) x) ds) then rl_mem l ds c
        else ()
    end

let rec lemma rl_contains (l : lit) (cnf : cnf) (c : clause) =
    requires { mem c cnf }
    ensures { mem (remove_lit (negate l) c) (map (fun x -> remove_lit (negate l) x) cnf) }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons _ ds ->
        if mem c ds then rl_contains l ds c
        else ()
    end

let rec lemma rl_no_redundant (l : lit) (c : clause) =
    requires { not (clause_redundant c) }
    ensures { not (clause_redundant (remove_lit (negate l) c)) }
    variant { c }
    match c with
    | Nil -> ()
    | Cons _ ms -> rl_no_redundant l ms
    end

function unit_prop (l : lit) (cnf : cnf) : cnf =
    if is_unit l cnf then (
        let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
        let no_pos = remove_containing_lit l no_neg in
        Cons (Cons l Nil) no_pos
    ) else cnf

lemma unit_prop_unit : forall l cnf .
    is_unit l cnf <-> is_unit l (unit_prop l cnf)

let lemma unit_prop_noneg (l l' : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf /\ is_unit l' cnf }
    requires { l <> negate l' }
    ensures { is_unit l' (unit_prop l cnf) /\ is_unit l (unit_prop l' cnf) }
    assert { remove_lit (negate l') (Cons l Nil) = Cons l Nil } ;
    assert { remove_lit (negate l) (Cons l' Nil) = Cons l' Nil }

let lemma unit_prop_nil (l : lit) (cnf : cnf) =
    requires { mem Nil cnf }
    requires { no_redundant_clauses cnf }
    ensures { mem Nil (unit_prop l cnf) }
    assert { remove_lit (negate l) Nil = Nil }

let lemma unit_prop_neg (l : lit) (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) }
    requires { is_unit l cnf }
    requires { mem (negate l) c }
    ensures { not (mem c (unit_prop l cnf)) }
    if pure { exists c' . mem c' (unit_prop l cnf) /\ mem (negate l) c' } then (
        let c' = any clause ensures { mem result (unit_prop l cnf) /\ mem (negate l) result } in
        let no_neg = map (fun x -> remove_lit (negate l) x) cnf in
        let no_pos = remove_containing_lit l no_neg in
        assert { mem c' no_pos /\ mem c' no_neg } ;
        assert { exists d . mem d cnf /\ remove_lit (negate l) d = c' } ;
        absurd
    )

let lemma unit_prop_no_redundant (l : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf }
    ensures { no_redundant_clauses (unit_prop l cnf) }
    let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
    let no_pos = remove_containing_lit l no_neg in
    if pure { exists c . mem c (unit_prop l cnf) /\ clause_redundant c } then (
        let c = any clause ensures { mem result (unit_prop l cnf) /\ clause_redundant result } in
        assert { mem c no_pos /\ mem c no_neg } ;
        let c' = any clause ensures { mem result cnf /\ remove_lit (negate l) result = c } in
        assert { clause_redundant c' } ;
        absurd
    )

let lemma unit_prop_no_trivial (l : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    ensures { no_trivial_clauses (unit_prop l cnf) }
    let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
    let no_pos = remove_containing_lit l no_neg in
    if pure { exists c . mem c (unit_prop l cnf) /\ clause_trivial c } then (
        let c = any clause ensures { mem result (unit_prop l cnf) /\ clause_trivial result } in
        let l' = any lit ensures { mem result c /\ mem (negate result) c } in
        assert { l.var <> l'.var by l <> l' /\ l <> negate l' } ;
        assert { mem c no_pos /\ mem c no_neg } ;
        let c' = any clause ensures { mem result cnf /\ remove_lit (negate l) result = c } in
        assert { clause_trivial c' by mem l' c' /\ mem (negate l') c' } ;
        absurd
    )

lemma unit_prop_occ : forall l cnf c .
    is_unit l cnf /\ mem l c /\ mem c (unit_prop l cnf) -> c = Cons l Nil

let lemma unit_prop_to_empty (l : lit) (cnf : cnf) =
    requires { is_unit l cnf /\ is_unit (negate l) cnf }
    ensures { mem Nil (unit_prop l cnf) }
    let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
    assert { mem Nil no_neg } 

let rec lemma unit_prop_clauses (l : lit) (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) }
    requires { is_unit l cnf }
    requires { not (mem l c) }
    requires { mem c cnf }
    ensures { mem (remove_lit (negate l) c) (unit_prop l cnf) }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons _ ds ->
        if is_unit l ds then (
            if mem c ds then unit_prop_clauses l ds c
            else ()
        ) else (
            let no_neg = map (fun x -> remove_lit (negate l) x) ds in
            let no_pos = remove_containing_lit l no_neg in
            assert { mem (remove_lit (negate l) c) no_pos } 
        )
    end

let rec lemma unit_prop_preserve_right (l : lit) (cnf : cnf) (rho : valuation) =
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf }
    requires { cnf_sat_with rho cnf }
    ensures { cnf_sat_with rho (unit_prop l cnf) }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons c cs -> 
        if is_unit l cs then (
            unit_prop_preserve_right l cs rho ;
            assert { clause_sat_with rho c } ;
            assert { cnf_sat_with rho (unit_prop l cs) } ;
            if mem l c then (
                assert { c <> Cons l Nil -> not (mem c (unit_prop l cs)) } ;
                assert { cnf_sat_with rho (unit_prop l cnf) by unit_prop l cnf = unit_prop l cs }
            ) else (
                let c' = remove_lit (negate l) c in
                let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
                assert { mem c' (unit_prop l cnf) by mem c' (remove_containing_lit l no_neg) } ;
                assert { exists l' . mem l' c /\ Map.get rho l'.var = l'.sign } ;
                let l' = any lit ensures { mem result c /\ Map.get rho result.var = result.sign } in
                if l'.var = l.var then (
                    assert { l' = negate l } ;
                    assert { not (clause_sat_with rho (Cons l Nil)) } ;
                    absurd
                ) ;
                assert { clause_sat_with rho (remove_lit (negate l) c) }
            )
        ) else (
            assert { c = Cons l Nil } ;
            assert { Map.get rho l.var = l.sign } ;
            let cnf' = unit_prop l cnf in
            if pure { exists c' . mem c' cnf' /\ not (clause_sat_with rho c') } then (
                let c' = any clause ensures { mem result cnf' /\ not (clause_sat_with rho result) } in
                let no_neg = map (fun c' -> remove_lit (negate l) c') cnf in
                assert { mem c' no_neg } ;
                let c'' = any clause ensures { mem result cnf /\ remove_lit (negate l) result = c' } in
                assert { clause_sat_with rho c'' } ;
                absurd
            )
        )
    end

let rec lemma unit_prop_preserve_left (l : lit) (cnf : cnf) (rho : valuation) =
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf }
    requires { cnf_sat_with rho (unit_prop l cnf) }
    ensures { cnf_sat_with rho cnf }
    variant { cnf }
    assert { Map.get rho l.var = l.sign by mem (Cons l Nil) (unit_prop l cnf) } ;
    match cnf with
    | Nil -> absurd
    | Cons c cs -> 
        if is_unit l cs then (
            unit_prop_preserve_left l cs rho ;
            assert { Map.get rho l.var = l.sign } ;
            if pure { not (clause_sat_with rho c) } then (
                let c' = remove_lit (negate l) c in
                assert { clause_sat_with rho c' } ;
                let l' = any lit ensures { mem result c' /\ Map.get rho result.var = result.sign } in
                assert { clause_sat_with rho c by mem l' c } ;
                absurd
            )
        ) else (
            if pure { exists c' . mem c' cnf /\ not (clause_sat_with rho c') } then (
                let c' = any clause ensures { mem result cnf /\ not (clause_sat_with rho result) } in
                assert { not (mem l c') by not (clause_sat_with rho c') /\ Map.get rho l.var = l.sign } ;
                assert { mem (remove_lit (negate l) c') (unit_prop l cnf) } ;
                absurd
            )
        )
    end

lemma unit_prop_preserve : forall l cnf rho .
    no_redundant_clauses cnf /\ is_unit l cnf -> (cnf_sat_with rho cnf <-> cnf_sat_with rho (unit_prop l cnf))

let lemma unit_prop_preserve_unsat (l : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf }
    ensures { cnf_unsat cnf <-> cnf_unsat (unit_prop l cnf) }
    if pure { exists rho . not (cnf_sat_with rho cnf) /\ cnf_sat_with rho (unit_prop l cnf) } then
        absurd
    else if pure { exists rho . cnf_sat_with rho cnf /\ not (cnf_sat_with rho (unit_prop l cnf)) } then
        absurd

predicate is_unit_chain (cnf : cnf) (chain : chain) =
    match chain with
    | Nil -> true
    | Cons l ls -> is_unit l cnf /\ is_unit_chain (unit_prop l cnf) ls
    end

function bcp (cnf : cnf) (chain : chain) : cnf =
    match chain with
    | Nil -> cnf
    | Cons l ls ->
        if is_unit l cnf then bcp (unit_prop l cnf) ls
        else cnf
    end

let rec lemma nil_unit_chain (cnf : cnf) (chain : chain) =
    requires { no_redundant_clauses cnf }
    requires { is_unit_chain cnf chain }
    requires { forall l . not (is_unit l cnf) }
    ensures { chain = Nil }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons _ _ -> absurd
    end

let rec lemma unit_chain_preserves_right (cnf : cnf) (chain : chain) (rho : valuation) =
    requires { no_redundant_clauses cnf }
    requires { is_unit_chain cnf chain }
    requires { cnf_sat_with rho cnf }
    ensures { cnf_sat_with rho (bcp cnf chain) }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l ls -> unit_chain_preserves_right (unit_prop l cnf) ls rho
    end

let rec lemma unit_chain_preserves_left (cnf : cnf) (chain : chain) (rho : valuation) =
    requires { no_redundant_clauses cnf }
    requires { is_unit_chain cnf chain }
    requires { cnf_sat_with rho (bcp cnf chain) }
    ensures { cnf_sat_with rho cnf }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l ls -> unit_chain_preserves_left (unit_prop l cnf) ls rho
    end

lemma unit_chain_preserves_sat : forall cnf chain rho .
    no_redundant_clauses cnf /\ is_unit_chain cnf chain -> (cnf_sat_with rho cnf <-> cnf_sat_with rho (bcp cnf chain))

let lemma unit_chain_preserves_unsat (cnf : cnf) (chain : chain) =
    requires { no_redundant_clauses cnf }
    requires { is_unit_chain cnf chain }
    ensures { cnf_unsat cnf <-> cnf_unsat (bcp cnf chain) }
    if pure { exists rho . not (cnf_sat_with rho cnf) /\ cnf_sat_with rho (bcp cnf chain) } then
        absurd
    else if pure { exists rho . cnf_sat_with rho cnf /\ not (cnf_sat_with rho (bcp cnf chain)) } then
        absurd

predicate props_to_conflict (cnf : cnf) =
    exists chain . is_unit_chain cnf chain /\ mem Nil (bcp cnf chain)

lemma props_to_conflict_unsat : forall cnf .
    no_redundant_clauses cnf /\ props_to_conflict cnf -> cnf_unsat cnf

let rec function negate_clause (c : clause) : cnf =
    match c with
    | Nil -> Cons (Cons {var=0 ; sign=true} (Cons {var=0 ; sign=false} Nil)) Nil
    | Cons l Nil -> Cons (Cons (negate l) Nil) Nil
    | Cons l ls -> Cons (Cons (negate l) Nil) (negate_clause ls)
    end

let rec lemma negated_all_units (c c' : clause) =
    requires { mem c' (negate_clause c) }
    requires { c <> Nil }
    ensures { exists l . mem (negate l) c /\ c' = (Cons l Nil) }
    variant { c }
    match c with
    | Nil -> absurd
    | Cons l Nil -> assert { c' = Cons (negate l) Nil } ;
    | Cons l ls -> 
        if mem c' (negate_clause ls) then negated_all_units ls c'
        else assert { c' = Cons (negate l) Nil } ;
    end

let rec lemma negated_contents (c : clause) =
    requires { c <> Nil }
    ensures { forall l . mem l c <-> mem (Cons (negate l) Nil) (negate_clause c) }
    variant { c }
    match c with
    | Nil -> absurd
    | Cons _ Nil -> ()
    | Cons _ ls -> negated_contents ls
    end

let rec lemma negated_not_trivial (c : clause) =
    requires { c <> Nil }
    ensures { no_trivial_clauses (negate_clause c) }
    variant { c }
    match c with
    | Nil -> absurd
    | Cons _ Nil -> ()
    | Cons _ ls -> negated_not_trivial ls
    end

let rec lemma negated_conflict (c : clause) =
    requires { cnf_unsat (negate_clause c) }
    ensures { exists l . is_unit l (negate_clause c) /\ is_unit (negate l) (negate_clause c) }
    variant { c }
    match c with
    | Nil -> assert { not (cnf_unsat (negate_clause c)) 
                        by exists rho . cnf_sat_with rho (negate_clause Nil)
                        by forall rho . cnf_sat_with rho (negate_clause Nil) } ;
    | Cons l Nil -> assert { cnf_sat_with (fun _ -> not l.sign) (negate_clause c) }
    | Cons l ls ->
        if is_unit l (negate_clause ls) then ()
        else (
            if cnf_unsat (negate_clause ls) then negated_conflict ls
            else 
                let rho = any valuation ensures { cnf_sat_with result (negate_clause ls) } in
                let rho' = Map.set rho l.var (not l.sign) in
                if not (cnf_sat_with rho' (negate_clause ls)) then (
                    let c' = any clause ensures { not (clause_sat_with rho' result) /\ mem result (negate_clause ls) } in
                    let l' = any lit ensures { c' = Cons result Nil } in
                    assert { Map.get rho l.var = l.sign } ;
                    assert { is_unit l (negate_clause ls) by l' = l } 
                ) else 
                    assert { cnf_sat_with rho' (negate_clause c) }
        )
    end

let lemma unsat_append (cnf cnf' : cnf) =
    requires { no_redundant_clauses cnf /\ no_redundant_clauses cnf' }
    requires { cnf_unsat (cnf ++ cnf') }
    requires { forall rho . cnf_sat_with rho cnf' }
    ensures { cnf_unsat cnf }
    if pure { exists rho . cnf_sat_with rho cnf } then (
        let rho = any valuation ensures { cnf_sat_with result cnf } in
        assert { cnf_sat_with rho cnf' } ;
        assert { forall c . mem c cnf' -> clause_sat_with rho c } ;
        assert { forall c . mem c cnf -> clause_sat_with rho c } ;
        assert { forall c . mem c (cnf ++ cnf') -> clause_sat_with rho c } ;
        assert { cnf_sat_with rho (cnf ++ cnf') } ;
        absurd
    )

let rec lemma no_neg_eq (l : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf }
    requires { forall c . mem c cnf -> not (mem (negate l) c) }
    ensures { cnf = map (fun c -> remove_lit (negate l) c) cnf }
    variant { cnf }
    match cnf with
    | Nil -> ()
    | Cons c cs -> 
        assert { c = remove_lit (negate l) c } ;
        no_neg_eq l cs
    end

let rec lemma no_pos_eq (l : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf }
    requires { forall c . mem c cnf -> not (mem l c) }
    ensures { cnf = remove_containing_lit l (Cons (Cons l Nil) cnf) }
    variant { cnf }
    match cnf with
    | Nil -> ()
    | Cons _ cs -> no_pos_eq l cs
    end

let lemma unit_prop_idempotent (l : lit) (cnf : cnf) =
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf }
    ensures { unit_prop l (unit_prop l cnf) = unit_prop l cnf }
    let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
    let no_pos = remove_containing_lit l no_neg in
    let up_l_cnf = Cons (Cons l Nil) no_pos in
    let no_neg' = map (fun c -> remove_lit (negate l) c) up_l_cnf in
    let no_pos' = remove_containing_lit l no_neg' in
    let up_l_up_l_cnf = Cons (Cons l Nil) no_pos' in
    assert { up_l_cnf = unit_prop l cnf } ;
    assert { up_l_up_l_cnf = unit_prop l up_l_cnf } ;
    assert { no_neg' = up_l_cnf } ;
    assert { no_pos' = no_pos }

let rec lemma is_unit_chain_after_prop (cnf : cnf) (l : lit) (chain : chain) =
  requires { is_unit_chain cnf (Cons l chain) }
  ensures { is_unit_chain (unit_prop l cnf) chain }
  variant { chain }
  match chain with
  | Nil -> ()
  | Cons l' ls ->
      assert { is_unit l' (unit_prop l cnf) } ;
      assert { is_unit_chain (unit_prop l cnf) (Cons l' ls) } ;
      is_unit_chain_after_prop (unit_prop l cnf) l' ls
  end

let lemma nil_props_conflict (cnf : cnf) (l : lit) =
    requires { mem Nil cnf }
    requires { is_unit l cnf }
    ensures { props_to_conflict (unit_prop l cnf) }
    let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
    assert { remove_lit (negate l) Nil = Nil } ;
    assert { mem Nil (unit_prop l cnf) by mem Nil no_neg /\ mem Nil (remove_containing_lit l no_neg) } ;
    assert { is_unit_chain (unit_prop l cnf) Nil /\ 
             mem Nil (bcp (unit_prop l cnf) Nil) } 

let rec lemma unit_prop_poss (l : lit) (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { mem c cnf }
    requires { is_unit l cnf }
    requires { not (mem l c) /\ not (mem (negate l) c) }
    ensures { mem c (unit_prop l cnf) }
    let no_neg = map (fun c' -> remove_lit (negate l) c') cnf in
    let no_pos = remove_containing_lit l no_neg in
    assert { mem c no_neg by not (mem (negate l) c) } ;
    assert { mem c no_pos }

let lemma unit_swap (cnf : cnf) (l l' : lit) =
    (* Why in the world is this lemma so hard to prove? *)
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf /\ is_unit l' cnf }
    requires { l <> l' /\ l <> negate l' }
    ensures { forall c . mem c (unit_prop l (unit_prop l' cnf)) <-> 
              mem c (unit_prop l' (unit_prop l cnf)) }

    let up_l_cnf = unit_prop l cnf in
    let up_l'_cnf = unit_prop l' cnf in

    assert { is_unit l up_l'_cnf } ;
    assert { is_unit l' up_l_cnf } ;

    let up_l_up_l'_cnf = unit_prop l up_l'_cnf in
    let up_l'_up_l_cnf = unit_prop l' up_l_cnf in

    assert { forall c . mem c up_l_cnf -> (c = Cons l Nil \/ not (mem l c)) /\ not (mem (negate l) c) } ;
    assert { forall c . mem c up_l'_cnf -> (c = Cons l' Nil \/ not (mem l' c)) /\ not (mem (negate l') c) } ;
    
    assert { forall c . mem c cnf /\ not (mem l c) /\ not (mem (negate l) c) -> mem c up_l_cnf } ;
    assert { forall c . mem c cnf /\ not (mem l' c) /\ not (mem (negate l') c) -> mem c up_l'_cnf } ;

    assert { forall c . mem c (remove_containing_lit l (map (fun c' -> remove_lit (negate l) c') up_l'_cnf)) -> 
             mem c (map (fun c' -> remove_lit (negate l) c') up_l'_cnf) } ;
    assert { forall c . mem c (remove_containing_lit l' (map (fun c' -> remove_lit (negate l') c') up_l_cnf)) -> 
             mem c (map (fun c' -> remove_lit (negate l') c') up_l_cnf) } ;

    assert { forall c . mem c (map (fun c' -> remove_lit (negate l) c') up_l'_cnf) -> 
             not (mem (negate l') c) /\ not (mem (negate l) c) /\ (c = Cons l' Nil \/ not (mem l' c)) } ;
    assert { forall c . mem c (map (fun c' -> remove_lit (negate l') c') up_l_cnf) -> 
             not (mem (negate l') c) /\ not (mem (negate l) c) /\ (c = Cons l Nil \/ not (mem l c)) } ;
    
    assert { forall c . mem c up_l_up_l'_cnf -> 
             (c = (Cons l Nil) \/ c = (Cons l' Nil) \/ (not (mem l c) /\ not (mem l' c))) } ;
    assert { forall c . mem c up_l_up_l'_cnf -> 
             not (mem (negate l) c) /\ not (mem (negate l') c) } ;
    
    assert { forall c . mem c up_l'_up_l_cnf -> 
             (c = (Cons l Nil) \/ c = (Cons l' Nil) \/ (not (mem l c) /\ not (mem l' c))) } ;
    assert { forall c . mem c up_l'_up_l_cnf -> 
             not (mem (negate l) c) /\ not (mem (negate l') c) } ;

    assert { forall c . mem c cnf /\ not (mem l c) /\ not (mem (negate l) c) /\ not (mem l' c) /\ not (mem (negate l') c) -> mem c up_l'_up_l_cnf } ;
    assert { forall c . mem c cnf /\ not (mem l c) /\ not (mem (negate l) c) /\ not (mem l' c) /\ not (mem (negate l') c) -> mem c up_l_up_l'_cnf } ;

    if pure { exists c . mem c up_l_up_l'_cnf /\ not (mem c up_l'_up_l_cnf) } then (
        let c = any clause ensures { mem result up_l_up_l'_cnf /\ not (mem result up_l'_up_l_cnf) } in
        assert { c <> Cons l Nil /\ c <> Cons l' Nil } ;
        assert { not (mem (negate l) c) /\ not (mem (negate l') c) /\ not (mem l c) /\ not (mem l' c) } ;
        if not (mem c cnf) then (
            assert { mem c (map (fun c -> remove_lit (negate l) c) up_l'_cnf) } ;
            assert { mem c up_l'_cnf \/ exists c' . mem c' up_l'_cnf /\ c = remove_lit (negate l) c' } ;
            if mem c up_l'_cnf then (
                assert { mem c (map (fun c -> remove_lit (negate l') c) cnf) } ;
                assert { mem c cnf \/ exists c' . mem c' cnf /\ c = remove_lit (negate l') c' } ;
                if mem c cnf then absurd
                else absurd
            ) else (
                let c' = any clause ensures { mem result up_l'_cnf /\ c = remove_lit (negate l) result } in
                assert { mem c' (map (fun c -> remove_lit (negate l') c) cnf) } ;
                assert { mem c' cnf \/ exists c'' . mem c'' cnf /\ c' = remove_lit (negate l') c'' } ;
                if mem c' cnf then absurd
                else (
                    let c'' = any clause ensures { mem result cnf /\ c' = remove_lit (negate l') result } in
                    let c''' = remove_lit (negate l) c'' in
                    assert { c = remove_lit (negate l) (remove_lit (negate l') c'') } ;
                    assert { c = remove_lit (negate l') c''' } ;
                    assert { mem (remove_lit (negate l') c''') up_l'_up_l_cnf } ;
                    absurd
                )
            )
        ) ;
        assert { mem c cnf } ;
        absurd
    ) ;
    assert { forall c . mem c up_l_up_l'_cnf -> mem c up_l'_up_l_cnf } ;

    if pure { exists c . mem c up_l'_up_l_cnf /\ not (mem c up_l_up_l'_cnf) } then (
        let c = any clause ensures { mem result up_l'_up_l_cnf /\ not (mem result up_l_up_l'_cnf) } in
        assert { c <> Cons l Nil /\ c <> Cons l' Nil } ;
        assert { not (mem (negate l) c) /\ not (mem (negate l') c) /\ not (mem l c) /\ not (mem l' c) } ;
        if not (mem c cnf) then (
            assert { mem c (map (fun c -> remove_lit (negate l') c) up_l_cnf) } ;
            assert { mem c up_l_cnf \/ exists c' . mem c' up_l_cnf /\ c = remove_lit (negate l') c' } ;
            if mem c up_l_cnf then (
                assert { mem c (map (fun c -> remove_lit (negate l) c) cnf) } ;
                assert { mem c cnf \/ exists c' . mem c' cnf /\ c = remove_lit (negate l) c' } ;
                if mem c cnf then absurd
                else absurd
            ) else (
                let c' = any clause ensures { mem result up_l_cnf /\ c = remove_lit (negate l') result } in
                assert { mem c' (map (fun c -> remove_lit (negate l) c) cnf) } ;
                assert { mem c' cnf \/ exists c'' . mem c'' cnf /\ c' = remove_lit (negate l) c'' } ;
                if mem c' cnf then absurd
                else (
                    let c'' = any clause ensures { mem result cnf /\ c' = remove_lit (negate l) result } in
                    let c''' = remove_lit (negate l') c'' in
                    assert { c = remove_lit (negate l') (remove_lit (negate l) c'') } ;
                    assert { c = remove_lit (negate l) c''' } ;
                    assert { mem (remove_lit (negate l) c''') up_l_up_l'_cnf } ;
                    absurd
                )
            )
        ) ;
        assert { mem c cnf } ;
        absurd
    ) ;
    assert { forall c . mem c up_l'_up_l_cnf -> mem c up_l_up_l'_cnf } 

let lemma unit_prop_nomatter (cnf cnf' : cnf) (l : lit) =
    requires { no_redundant_clauses cnf /\ no_redundant_clauses cnf' }
    requires { is_unit l cnf }
    requires { forall c . mem c cnf <-> mem c cnf' }
    ensures { forall c . mem c (unit_prop l cnf) <-> mem c (unit_prop l cnf') }
    assert { is_unit l cnf' } ;
    let no_neg = map (fun c -> remove_lit (negate l) c) cnf in
    let no_neg' = map (fun c -> remove_lit (negate l) c) cnf' in
    let no_pos = remove_containing_lit l no_neg in
    let no_pos' = remove_containing_lit l no_neg' in
    assert { forall c . mem c no_neg <-> mem c no_neg' } ;
    assert { forall c . mem c no_pos <-> mem c no_pos' } ;
    if pure { exists c . mem c (unit_prop l cnf) /\ not (mem c (unit_prop l cnf')) } then (
        let c = any clause ensures { mem result (unit_prop l cnf) /\ not (mem result (unit_prop l cnf')) } in
        assert { mem c no_pos' by mem c no_pos } ;
        absurd
    ) ;
    if pure { exists c . mem c (unit_prop l cnf') /\ not (mem c (unit_prop l cnf)) } then (
        let c = any clause ensures { mem result (unit_prop l cnf') /\ not (mem result (unit_prop l cnf)) } in
        assert { mem c no_pos by mem c no_pos' } ;
        absurd
    )

let rec lemma unit_chain_nomatter (cnf cnf' : cnf) (chain : chain) =
    requires { no_redundant_clauses cnf /\ no_redundant_clauses cnf' }
    requires { is_unit_chain cnf chain }
    requires { forall c . mem c cnf <-> mem c cnf' }
    ensures { is_unit_chain cnf' chain }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l ls -> unit_chain_nomatter (unit_prop l cnf) (unit_prop l cnf') ls
    end

let rec lemma bcp_nomatter (cnf cnf' : cnf) (chain : chain) =
    requires { no_redundant_clauses cnf /\ no_redundant_clauses cnf' }
    requires { is_unit_chain cnf chain }
    requires { forall c . mem c cnf <-> mem c cnf' }
    ensures { forall c . mem c (bcp cnf chain) <-> mem c (bcp cnf' chain) }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l ls -> bcp_nomatter (unit_prop l cnf) (unit_prop l cnf') ls
    end

let rec lemma unit_always_chain (cnf : cnf) (l : lit) (chain : chain) =
    requires { no_redundant_clauses cnf }
    requires { is_unit_chain cnf chain }
    requires { is_unit l cnf }
    requires { forall l' . mem l' chain -> l <> negate l' }
    ensures { is_unit_chain (unit_prop l cnf) chain }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l' chain' ->
        let up_cnf = unit_prop l' cnf in
        assert { is_unit l' cnf } ;
        assert { is_unit_chain cnf (Cons l' chain') } ;
        if pure { l = l' } then (
            assert { is_unit_chain (unit_prop l cnf) chain' } ;
            assert { unit_prop l (unit_prop l cnf) = unit_prop l cnf } ;
            assert { is_unit l (unit_prop l cnf) } ;
        ) else if pure { l = negate l' } then (
            absurd
        ) else (
            unit_always_chain up_cnf l chain' ;
            assert { is_unit_chain (unit_prop l (unit_prop l' cnf)) chain' } ;
            unit_swap cnf l l' ;
            unit_chain_nomatter (unit_prop l (unit_prop l' cnf)) (unit_prop l' (unit_prop l cnf)) chain' ;
            assert { is_unit_chain (unit_prop l' (unit_prop l cnf)) chain' } ;
            assert { is_unit_chain (unit_prop l cnf) (Cons l' chain') } 
        )
    end

let rec lemma unit_chain_mono (cnf : cnf) (chain : chain) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { is_unit_chain cnf chain }
    ensures { forall l . is_unit_chain (Cons (Cons l (Cons (negate l) Nil)) cnf) chain }
    variant { chain }
    if pure { exists l . not (is_unit_chain (Cons (Cons l (Cons (negate l) Nil)) cnf) chain) } then
        let l = any lit ensures { not (is_unit_chain (Cons (Cons result (Cons (negate result) Nil)) cnf) chain) } in
        let c = Cons l (Cons (negate l) Nil) in
        match chain with
        | Nil -> absurd
        | Cons l' ls' ->
            assert { is_unit l' (Cons c cnf) by is_unit l' cnf } ;
            if pure { l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons l Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons l Nil } ;
                absurd
            ) else if pure { negate l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons (negate l) Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons (negate l) Nil } ;
                absurd
            ) else (
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem c no_neg' by remove_lit (negate l') c = c } ;
                assert { forall c' . mem c' (unit_prop l' (Cons c cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                unit_chain_mono (unit_prop l' cnf) ls' ;
                assert { forall c' . mem c' (Cons c (unit_prop l' cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                assert { not (clause_redundant c) } ;
                unit_chain_nomatter (Cons c (unit_prop l' cnf)) (unit_prop l' (Cons c cnf)) ls' ;
                absurd
            )
        end

let rec lemma unit_chain_mono' (cnf : cnf) (chain : chain) (l : lit) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { is_unit_chain (Cons (Cons l (Cons (negate l) Nil)) cnf) chain }
    ensures { is_unit_chain cnf chain }
    variant { chain }
    if pure { not (is_unit_chain cnf chain) } then
        let c = Cons l (Cons (negate l) Nil) in
        match chain with
        | Nil -> absurd
        | Cons l' ls' ->
            assert { is_unit l' cnf } ;
            if pure { l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons l Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons l Nil } ;
                absurd
            ) else if pure { negate l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons (negate l) Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons (negate l) Nil } ;
                absurd
            ) else (
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem c no_neg' by remove_lit (negate l') c = c } ;
                assert { forall c' . mem c' (unit_prop l' (Cons c cnf)) <-> mem c' (Cons c (unit_prop l' (Cons c cnf))) } ;
                unit_chain_nomatter (unit_prop l' (Cons c cnf)) (Cons c (unit_prop l' cnf)) ls' ;
                unit_chain_mono' (unit_prop l' cnf) ls' l ;
                assert { forall c' . mem c' (Cons c (unit_prop l' cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                assert { not (clause_redundant c) } ;
                unit_chain_nomatter (Cons c (unit_prop l' cnf)) (unit_prop l' (Cons c cnf)) ls' ;
                absurd
            )
        end

let rec lemma unit_prop_mono (cnf : cnf) (chain : chain) (cc : clause) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { not (clause_redundant cc) }
    requires { is_unit_chain cnf chain }
    requires { mem cc (bcp cnf chain) }
    ensures { forall l . mem cc (bcp (Cons (Cons l (Cons (negate l) Nil)) cnf) chain) }
    variant { chain }
    if pure { exists l . not (mem cc (bcp (Cons (Cons l (Cons (negate l) Nil)) cnf) chain)) } then
        let l = any lit ensures { not (mem cc (bcp (Cons (Cons result (Cons (negate result) Nil)) cnf) chain)) } in
        let c = Cons l (Cons (negate l) Nil) in
        match chain with
        | Nil -> absurd
        | Cons l' ls' ->
            assert { is_unit l' (Cons c cnf) by is_unit l' cnf } ;
            if pure { l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons l Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons l Nil } ;
                absurd
            ) else if pure { negate l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons (negate l) Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons (negate l) Nil } ;
                absurd
            ) else (
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem c no_neg' by remove_lit (negate l') c = c } ;
                assert { forall c' . mem c' (unit_prop l' (Cons c cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                unit_prop_mono (unit_prop l' cnf) ls' cc ;
                assert { forall c' . mem c' (Cons c (unit_prop l' cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                assert { not (clause_redundant c) } ;
                bcp_nomatter (Cons c (unit_prop l' cnf)) (unit_prop l' (Cons c cnf)) ls' ;
                absurd
            )
        end

let rec lemma unit_prop_mono' (cnf : cnf) (chain : chain) (cc : clause) (l : lit) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { not (clause_redundant cc) }
    requires { is_unit_chain cnf chain }
    requires { cc <> Cons l (Cons (negate l) Nil) }
    requires { mem cc (bcp (Cons (Cons l (Cons (negate l) Nil)) cnf) chain) }
    ensures { mem cc (bcp cnf chain) }
    variant { chain }
    if pure { not (mem cc (bcp cnf chain)) } then
        let c = Cons l (Cons (negate l) Nil) in
        match chain with
        | Nil -> absurd
        | Cons l' ls' ->
            assert { is_unit l' (Cons c cnf) by is_unit l' cnf } ;
            if pure { l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons l Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons l Nil } ;
                absurd
            ) else if pure { negate l = l' } then (
                let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem (Cons l Nil) no_neg' by remove_lit (negate l') c = Cons (negate l) Nil } ;
                assert { forall c' . mem c' no_neg' <-> mem c' no_neg \/ c' = Cons (negate l) Nil } ;
                absurd
            ) else (
                let no_neg' = map (fun c -> remove_lit (negate l') c) (Cons c cnf) in
                assert { mem c no_neg' by remove_lit (negate l') c = c } ;
                assert { forall c' . mem c' (unit_prop l' (Cons c cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                assert { forall c' . mem c' (unit_prop l' (Cons c cnf)) <-> mem c' (Cons c (unit_prop l' (Cons c cnf))) } ;
                unit_chain_nomatter (unit_prop l' (Cons c cnf)) (Cons c (unit_prop l' cnf)) ls' ;
                bcp_nomatter (unit_prop l' (Cons c cnf)) (Cons c (unit_prop l' cnf)) ls' ;
                unit_prop_mono' (unit_prop l' cnf) ls' cc l ;
                assert { forall c' . mem c' (Cons c (unit_prop l' cnf)) <-> mem c' (unit_prop l' cnf) \/ c' = c } ;
                assert { not (clause_redundant c) } ;
                bcp_nomatter (Cons c (unit_prop l' cnf)) (unit_prop l' (Cons c cnf)) ls' ;
                absurd
            )
        end

let rec lemma prop_preserves_prop (cnf : cnf) (l : lit) (chain : chain) =
    (* This is surprisingly difficult to prove: if a CNF propagates to a conflict,
       then the CNF that comes from propagating a unit literal will also propagate
       to a conflict. Having this simplifies the verification of do_bcp below. *)
    requires { no_redundant_clauses cnf }
    requires { is_unit_chain cnf chain }
    requires { mem Nil (bcp cnf chain) }
    requires { is_unit l cnf }
    ensures { props_to_conflict (unit_prop l cnf) }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l' chain' ->
        if mem Nil cnf then assert { mem Nil (unit_prop l cnf) } 
        else (
            if pure { l = negate l' } then (
                assert { remove_lit (negate l) (Cons (negate l) Nil) = Nil } ;
                assert { is_unit_chain cnf (Cons l Nil) }
            ) else if pure { l = l' } then 
                assert { mem Nil (bcp (unit_prop l cnf) chain') } 
            else (
                if pure { chain' = Nil } then (
                    assert { is_unit_chain (unit_prop l cnf) (Cons l' Nil) } ;
                    if pure { not (mem (Cons (negate l') Nil) cnf) } then (
                        assert { remove_lit (negate l') (Cons (negate l') Nil) = Nil } ;
                        if pure { not (exists c . mem c cnf /\ remove_lit (negate l') c = Nil) } then (
                            let no_neg = map (fun c -> remove_lit (negate l') c) cnf in
                            let no_pos = remove_containing_lit l' no_neg in
                            assert { mem Nil no_pos /\ mem Nil no_neg } ;
                            absurd
                        ) ;
                        let c = any clause ensures { remove_lit (negate l') result = Nil /\ mem result cnf } in
                        assert { c = Cons (negate l') Nil } ;
                        absurd
                    ) ;
                    if pure { not (mem (Cons (negate l') Nil) (unit_prop l cnf)) } then (
                        assert { l <> l' } ;
                        absurd
                    ) ;
                    unit_prop_nil l (unit_prop l' cnf) 
                ) else (
                    prop_preserves_prop (unit_prop l' cnf) l chain' ;
                    let chain'' = any chain ensures { is_unit_chain (unit_prop l (unit_prop l' cnf)) result /\ 
                                                      mem Nil (bcp (unit_prop l (unit_prop l' cnf)) result) } in
                    if not (is_unit_chain (unit_prop l cnf) (Cons l' (Cons l chain''))) then (
                        if not (is_unit_chain (unit_prop l' (unit_prop l cnf)) (Cons l chain'')) then (
                            assert { not (is_unit_chain (unit_prop l (unit_prop l' (unit_prop l cnf))) chain'') } ;
                            absurd
                        ) ;
                        absurd
                    ) ;
                    if not (is_unit_chain (unit_prop l cnf) (Cons l' chain'')) then (
                        if not (is_unit_chain (unit_prop l (unit_prop l' cnf)) (Cons l' chain'')) then (
                            assert { not (is_unit_chain (unit_prop l' (unit_prop l (unit_prop l' cnf))) chain'') } ;
                            absurd
                        ) ;
                        absurd
                    ) ;
                    assert { bcp (unit_prop l cnf) (Cons l' chain'') = bcp (unit_prop l' (unit_prop l cnf)) chain'' } ;
                    assert { mem Nil (bcp cnf (Cons l (Cons l' chain''))) }
                ) 
            )
        )
    end

let rec lemma exhausted_chains (cnf : cnf) (chain : chain) =
    requires { no_redundant_clauses cnf }
    requires { forall l . is_unit l cnf -> forall c . mem c (unit_prop l cnf) <-> mem c cnf }
    requires { is_unit_chain cnf chain }
    ensures { forall c . mem c (bcp cnf chain) <-> mem c cnf }
    variant { chain }
    match chain with
    | Nil -> ()
    | Cons l chain' -> 
        let cnf' = unit_prop l cnf in
        assert { forall c . mem c cnf <-> mem c cnf' } ;
        exhausted_chains cnf' chain'
    end

let rec lemma prop_preserves_fixed (cnf : cnf) (l l' : lit) =
    requires { no_redundant_clauses cnf }
    requires { is_unit l cnf /\ is_unit l' cnf }
    requires { l <> negate l' }
    requires { forall c . mem c (unit_prop l' cnf) <-> mem c cnf }
    ensures { forall c . mem c (unit_prop l' (unit_prop l cnf)) <-> mem c (unit_prop l cnf) }
    variant { cnf }
    if pure { l = l' } then ()
    else (
        if pure { exists c . mem c (unit_prop l' (unit_prop l cnf)) /\ not (mem c (unit_prop l cnf)) } then (
            let c = any clause ensures { mem result (unit_prop l' (unit_prop l cnf)) /\ not (mem result (unit_prop l cnf)) } in
            let cnf' = unit_prop l cnf in
            let no_neg = map (fun c -> remove_lit (negate l') c) cnf' in
            assert { not (mem c cnf) } ;
            assert { mem c no_neg } ;
            let c' = any clause ensures { c = remove_lit (negate l') result /\ mem result cnf' } in
            assert { mem (negate l') c' by c' <> c } ;
            let no_neg' = map (fun c -> remove_lit (negate l) c) cnf in
            assert { mem c' no_neg' } ;
            let c'' = any clause ensures { c' = remove_lit (negate l) result /\ mem result cnf } in
            assert { mem (negate l') c'' } ;
            absurd 
        ) ;
        if pure { exists c . not (mem c (unit_prop l' (unit_prop l cnf))) /\ mem c (unit_prop l cnf) } then absurd
    )

predicate implied (cnf : cnf) (c : clause) =
    forall rho . cnf_sat_with rho cnf -> clause_sat_with rho c

predicate subsumes (c c' : clause) =
  forall l . mem l c -> mem l c'

predicate equisat (cnf cnf' : cnf) =
    (exists rho . cnf_sat_with rho cnf) <-> (exists rho . cnf_sat_with rho cnf')

let lemma subsumed_equisat (cnf : cnf) (c c' : clause) =
  requires { mem c cnf }
  requires { subsumes c c' }
  ensures { equisat cnf (Cons c' cnf) }
  if pure { exists rho . cnf_sat_with rho cnf } then (
    let rho = any valuation ensures { cnf_sat_with result cnf } in
    let l = any lit ensures { mem result c /\ Map.get rho result.var = result.sign } in
    assert { mem l c' } ;
    assert { clause_sat_with rho c' } ;
    assert { cnf_sat_with rho (Cons c' cnf) }
  ) ;
  if pure { exists rho . cnf_sat_with rho (Cons c' cnf) } then (
    let rho = any valuation ensures { cnf_sat_with result (Cons c' cnf) } in
    assert { cnf_sat_with rho cnf } 
  ) 

let lemma implied_implies_equisat (cnf : cnf) (c : clause) =
    requires { implied cnf c }
    ensures { equisat cnf (Cons c cnf) }
    if pure { (exists rho . cnf_sat_with rho cnf) /\ not (exists rho . cnf_sat_with rho (Cons c cnf)) } then (
        let rho = any valuation ensures { cnf_sat_with result cnf } in
        assert { clause_sat_with rho c by implied cnf c } ;
        assert { cnf_sat_with rho (Cons c cnf) } ;
        absurd
    ) ;
    if pure { not (exists rho . cnf_sat_with rho cnf) /\ (exists rho . cnf_sat_with rho (Cons c cnf)) } then (
        let rho = any valuation ensures { cnf_sat_with result (Cons c cnf) } in
        assert { cnf_sat_with rho cnf } ;
        absurd
    )

let rec lemma implied_clause (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) }
    requires { cnf_unsat (cnf ++ negate_clause c) }
    ensures { implied cnf c }
    variant { cnf }
    let c' = negate_clause c in
    if pure { c = Nil } then (
        assert { forall rho . cnf_sat_with rho c' } ;
        assert { cnf_unsat cnf }
    ) else (
        if pure { exists rho . cnf_sat_with rho cnf /\ not (clause_sat_with rho c) } then (
            let rho = any valuation ensures { cnf_sat_with result cnf /\ not (clause_sat_with result c) } in
            assert { forall l . mem l c -> Map.get rho l.var = not l.sign } ;
            if pure { forall c' . mem c' (cnf ++ negate_clause c) -> clause_sat_with rho c' } then
                assert { not (cnf_unsat (cnf ++ negate_clause c)) 
                            by cnf_sat_with rho (cnf ++ negate_clause c) }
            else
                assert { not (cnf_sat_with rho (negate_clause c)) 
                            by forall c' . mem c' cnf -> clause_sat_with rho c'  }
        )
    )

predicate rup (cnf : cnf) (c : clause) =
    props_to_conflict (cnf ++ (negate_clause c))

let lemma redundant_append (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) }
    ensures { no_redundant_clauses (cnf ++ negate_clause c) }
    if pure { exists c' . mem c' (cnf ++ negate_clause c) /\ clause_redundant c' } then (
        let c' = any clause ensures { mem result (cnf ++ negate_clause c) /\ clause_redundant result } in
        assert { not (mem c' cnf) } ;
        assert { exists l . mem (negate l) c /\ c' = Cons l Nil } ;
        assert { forall l . not (clause_redundant (Cons l Nil)) } ;
        absurd
    )

let lemma rup_implied (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) }
    requires { rup cnf c }
    ensures { implied cnf c }
    assert { no_redundant_clauses (cnf ++ negate_clause c) by no_redundant_clauses cnf /\ not (clause_redundant c) } ;
    assert { cnf_unsat (cnf ++ negate_clause c) by props_to_conflict (cnf ++ negate_clause c) } ;
    implied_clause cnf c

function resolve (c c' : clause) (l : lit) : clause =
    if mem l c && mem (negate l) c' then
        remove_redundant_lits ((remove_lit l c) ++ (remove_lit (negate l) c'))
    else remove_redundant_lits (c ++ c')

lemma resolve_not_redundant : forall c c' l .
    not (clause_redundant (resolve c c' l))

let lemma resolve_implied (cnf : cnf) (c c' : clause) (l : lit) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) /\ not (clause_redundant c') }
    requires { mem c cnf /\ mem c' cnf }
    requires { mem l c /\ mem (negate l) c' }
    ensures { implied cnf (resolve c c' l) }
    let cnf' = Cons (resolve c c' l) cnf in
    if pure { exists rho . cnf_sat_with rho cnf /\ not (cnf_sat_with rho cnf') } then
        let rho = any valuation ensures { cnf_sat_with result cnf /\ not (cnf_sat_with result cnf') } in
        assert { not (clause_sat_with rho (resolve c c' l)) } ;
        let l' = any lit ensures { mem result c /\ Map.get rho result.var = result.sign } in
        if pure { l = l' } then (
            let l'' = any lit ensures { mem result c' /\ Map.get rho result.var = result.sign } in
            assert { forall l''' . mem l''' c' /\ l''' <> negate l -> mem l''' (resolve c c' l) } ;
            assert { mem l'' (resolve c c' l) by l'' <> negate l } ;
            absurd
        ) else absurd

function pivot_clauses (cnf : cnf) (l : lit) : list clause =
    match cnf with
    | Nil -> Nil
    | Cons c cs -> if mem (negate l) c then Cons c (pivot_clauses cs l) else pivot_clauses cs l
    end

let rec lemma pivot_sub (cnf :  cnf) (c : clause) (l : lit) =
    requires { no_redundant_clauses cnf }
    requires { mem c (pivot_clauses cnf l) }
    ensures { mem c cnf }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons c' cs -> 
        if pure { c = c' } then 
            assert { mem c' (pivot_clauses cnf l)}
        else pivot_sub cs c l
    end

let rec lemma pivot_mem (cnf : cnf) (c : clause) (l : lit) =
    requires { no_redundant_clauses cnf }
    requires { not (clause_redundant c) }
    requires { mem c (pivot_clauses cnf l) }
    ensures { mem c cnf /\ mem (negate l) c }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons c' cs -> 
        if pure { c = c' } then 
            if pure { mem (negate l) c' } then
                assert { mem c' (pivot_clauses cnf l)}
            else
                pivot_mem cs c l
        else pivot_mem cs c l
    end

let rec lemma pivot_nil (cnf : cnf) (l : lit) (rho : valuation) =
    requires { no_redundant_clauses cnf }
    requires { pivot_clauses cnf l = Nil }
    requires { cnf_sat_with rho cnf }
    ensures { cnf_sat_with (Map.set rho l.var l.sign) cnf }
    variant { cnf }
    match cnf with
    | Nil -> ()
    | Cons c cs ->
        assert { not (mem (negate l) c) by pivot_clauses cnf l = Nil } ;
        assert { clause_sat_with (Map.set rho l.var l.sign) c } ;
        pivot_nil cs l rho
    end

let rec lemma pivot_complete (cnf : cnf) (l : lit) (c : clause) =
    requires { no_redundant_clauses cnf }
    requires { mem c cnf /\ mem (negate l) c }
    ensures { mem c (pivot_clauses cnf l) }
    variant { cnf }
    match cnf with
    | Nil -> absurd
    | Cons c' cs -> 
        if pure { c = c' } then 
            assert { mem c' (pivot_clauses cnf l)}
        else pivot_complete cs l c
    end

predicate rat (cnf : cnf) (c : clause) =
    match c with
    | Nil -> false
    | Cons l _ -> forall c' . mem c' (pivot_clauses cnf l) -> rup cnf (resolve c c' l)
    end

let lemma rat_equisat (cnf : cnf) (c : clause) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { not (clause_redundant c) /\ not (clause_trivial c) }
    requires { rat cnf c }
    ensures { equisat cnf (Cons c cnf) }
    match c with
    | Nil -> absurd
    | Cons l ls ->
        if pure { (exists rho . cnf_sat_with rho cnf) /\ not (exists rho . (cnf_sat_with rho (Cons c cnf))) } then (
            let rho = any valuation ensures { cnf_sat_with result cnf } in
            assert { not (clause_sat_with rho c) by cnf_sat_with rho cnf /\ not (cnf_sat_with rho (Cons c cnf)) } ;
            assert { Map.get rho l.var = not l.sign } ;
            let rho' = Map.set rho l.var l.sign in
            if pure { exists c' . mem c' cnf /\ not (clause_sat_with rho' c') } then (
                let c' = any clause ensures { mem result cnf /\ not (clause_sat_with rho' result) } in
                if not (mem (negate l) c' ) then (
                    let l' = any lit ensures { mem result c' /\ Map.get rho result.var = result.sign } in
                    assert { Map.get rho' l'.var = Map.get rho l'.var } ;
                    absurd ;
                ) ;
                assert { mem c' (pivot_clauses cnf l) } ;
                match ls with
                | Nil ->
                    assert { remove_lit (negate l) c' = remove_redundant_lits (remove_lit (negate l) c') } ;
                    assert { rup cnf (remove_lit (negate l) c') by remove_lit l c = Nil } ;
                    assert { clause_sat_with rho' (remove_lit (negate l) c') 
                             by not (mem (negate l) (remove_lit (negate l) c')) 
                                 /\ clause_sat_with rho (remove_lit (negate l) c') } ;
                    absurd
                | Cons _ _ ->
                    assert { rup cnf (resolve c c' l) } ;
                    if not (clause_sat_with rho (resolve c c' l)) then (
                        assert { not (clause_redundant (resolve c c' l)) } ;
                        absurd
                    ) ;
                    assert { clause_sat_with rho' (resolve c c' l) 
                             by (not (mem (negate l) (resolve c c' l)) 
                                 /\ clause_sat_with rho (resolve c c' l)) } ;
                    let l'' = any lit ensures { mem result (resolve c c' l) /\ Map.get rho' result.var = result.sign } in
                    assert { l'' <> (negate l) /\ l'' <> l } ;
                    if mem l'' c then absurd
                    else absurd 
                    (* absurd *)
                end ;
            ) ;
            assert { forall c' . mem c' cnf -> clause_sat_with rho' c' } ;
            assert { clause_sat_with rho' c } ;
            assert { cnf_sat_with rho' (Cons c cnf) } ;
            absurd
        )
    end

predicate valid_proof (cnf : cnf) (pf : proof) =
    match pf with
    | Nil -> props_to_conflict cnf
    | Cons c cs -> (rup cnf c \/ rat cnf c) /\ valid_proof (Cons c cnf) cs
    end

predicate valid_derivation (cnf : cnf) (pf : proof) =
    match pf with
    | Nil -> true
    | Cons c cs -> (rup cnf c \/ rat cnf c) /\ valid_derivation (Cons c cnf) cs
    end

let rec lemma valid_proof_means_unsat (cnf : cnf) (pf : proof) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { no_redundant_clauses pf /\ no_trivial_clauses pf }
    requires { valid_proof cnf pf }
    ensures { cnf_unsat cnf }
    variant { pf }
    match pf with
    | Nil -> ()
    | Cons c cs -> 
        valid_proof_means_unsat (Cons c cnf) cs ;
        if pure { exists rho . cnf_sat_with rho cnf } then
            let rho = any valuation ensures { cnf_sat_with result cnf } in
            assert { cnf_sat_with rho (Cons c cnf) by 
                        clause_sat_with rho c /\ forall c' . mem c' cnf -> clause_sat_with rho c' }
    end

(*************************************************************)
(* Implementation                                            *)
(*************************************************************)

let rec function do_mem (x : 'a) (xs : list 'a) (eq : 'a -> 'a -> bool) : bool =
    requires { forall y . eq x y <-> x = y }
    ensures { result = mem x xs }
    match xs with
    | Nil -> false
    | Cons y ys -> (eq x y) || do_mem x ys eq
    end

let predicate (==) (x y : bool) : bool =
    (x && y) || (not x && not y)

let predicate lit_eq (l1 l2 : lit) =
    ensures { result <-> l1.var = l2.var && l1.sign = l2.sign }
    l1.var = l2.var && l1.sign == l2.sign

let rec function do_remove_containing_lit (l : lit) (cnf : cnf) : cnf =
    ensures { result = remove_containing_lit l cnf }
    variant { cnf }
    match cnf with
    | Nil -> Nil
    | Cons c cs -> 
        if do_mem l c lit_eq then do_remove_containing_lit l cs
        else Cons c (do_remove_containing_lit l cs)
    end

let rec function check_unit (l : lit) (cnf : cnf) : bool =
    ensures { result = is_unit l cnf }
    variant { cnf }
    match cnf with
    | Nil -> false
    | Cons c cs -> 
        match c with
        | Nil -> check_unit l cs
        | Cons l' Nil -> lit_eq l l' || check_unit l cs
        | Cons _ _ -> check_unit l cs
        end
    end

let rec function do_remove_lit (l : lit) (c : clause) : clause =
    requires { not (clause_redundant c) }
    ensures { result = remove_lit l c }
    ensures { not (clause_redundant result) }
    variant { c }
    match c with
    | Nil -> Nil
    | Cons l' c' -> 
        if lit_eq l l' then do_remove_lit l c' 
        else Cons l' (do_remove_lit l c')
    end

let function do_unit_prop (l : lit) (cnf : cnf) : cnf =
    requires { no_redundant_clauses cnf }
    ensures { result = unit_prop l cnf }
    assert { forall c . mem c cnf -> not (clause_redundant c) } ;
    let rec function do_map (l' : lit) (xs : cnf) : cnf =
        requires { no_redundant_clauses xs }
        ensures { result = map (fun x -> remove_lit l' x) xs }
        ensures { no_redundant_clauses result }
        variant { xs }
        match xs with
        | Nil -> Nil
        | Cons x xs' -> Cons (do_remove_lit l' x) (do_map l' xs')
        end
    in
    if check_unit l cnf then
        let no_neg = do_map (negate l) cnf in
        let no_pos = do_remove_containing_lit l no_neg in (
            assert { no_neg = map (fun c -> remove_lit (negate l) c) cnf } ;
            Cons (Cons l Nil) no_pos
        )
    else cnf

let rec function find_unit (cnf : cnf) (ignore : chain) : option lit =
    ensures { match result with
              | None -> forall l . (not (is_unit l cnf) \/ mem l ignore)
              | Some l -> Fset.mem l (cnf_lits cnf) /\ is_unit l cnf /\ not (mem l ignore)
              end }
    match cnf with
    | Nil -> None
    | Cons c cs -> 
        match c with
        | Nil -> find_unit cs ignore
        | Cons l Nil -> if do_mem l ignore lit_eq then find_unit cs ignore else Some l
        | Cons _ _ -> find_unit cs ignore
        end
    end

let rec predicate clause_eq (c1 c2 : clause) =
    ensures { result <-> c1 = c2 }
    variant { c1, c2 }
    match c1, c2 with
    | Nil, Nil -> true
    | Cons l1 c1', Cons l2 c2' -> lit_eq l1 l2 && clause_eq c1' c2'
    | _, _ -> false
    end

let rec check_trivial (c : clause) : bool =
    ensures { result <-> clause_trivial c }
    variant { c }
    match c with
    | Nil -> false
    | Cons l ls -> if do_mem (negate l) ls lit_eq then true else check_trivial ls
    end

let rec do_bcp (cnf : cnf) (prop : list lit) (ghost poss_lits : Fset.fset lit) : (chain, cnf, bool) =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { forall l . Fset.mem l (cnf_lits cnf) /\ not (mem l prop) -> Fset.mem l poss_lits }
    requires { forall l . mem l prop -> is_unit l cnf }
    requires { forall l . mem l prop -> forall c . mem c (unit_prop l cnf) <-> mem c cnf }
    ensures { let _, _, conflict = result in conflict <-> props_to_conflict cnf }
    ensures { let chain', cnf', conflict' = result in 
              is_unit_chain cnf chain' /\ 
              cnf' = bcp cnf chain' /\
              (mem Nil cnf' <-> conflict') /\
              (not conflict' -> forall chain . is_unit_chain cnf' chain -> 
                                               forall c . mem c (bcp cnf' chain) <-> mem c cnf') }
    variant { Fset.cardinal poss_lits }
    if do_mem Nil cnf clause_eq then (
        assert { props_to_conflict cnf by is_unit_chain cnf Nil /\ cnf = bcp cnf Nil /\ mem Nil cnf } ;
        (Nil, cnf, true)
    ) else
        match find_unit cnf prop with
        | None ->
            let ghost b = mem Nil cnf in
            (* Either there aren't any unit literals, or they've all been propagated already.
             * In the latter case, further propagation is idempotent, so it's safe
             * to return an empty chain in any case. *)
            if pure { forall l . not (is_unit l cnf) } then
                assert { forall chain . is_unit_chain cnf chain -> chain = Nil } 
            else (
                assert { forall l . is_unit l cnf -> mem l prop } ;
                assert { forall l . is_unit l cnf -> forall c . mem c (unit_prop l cnf) <-> mem c cnf } ;
                assert { forall chain . is_unit_chain cnf chain -> forall c . mem c (bcp cnf chain) <-> mem c cnf } 
            ) ;
            assert { b -> props_to_conflict cnf by mem Nil (bcp cnf Nil) } ;
            (Nil, cnf, false)
        | Some l -> 
            let cnf' = (do_unit_prop l cnf) in
            (* To show termination, we need to prove that every literal 
             * that hasn't been propagated already is in poss_lits *)
            if pure { exists l' . Fset.mem l' (cnf_lits cnf') /\ 
                                  not (mem l' (Cons l prop)) /\ 
                                  not (Fset.mem l' (Fset.remove l poss_lits)) } 
            then (
                let l' = any lit ensures { Fset.mem result (cnf_lits cnf') /\ 
                                           not (mem result (Cons l prop)) /\ 
                                           not (Fset.mem result (Fset.remove l poss_lits)) } 
                in
                assert { l <> l' -> (Fset.mem l' poss_lits <-> Fset.mem l' (Fset.remove l poss_lits)) } ;
                if pure { l = l' } then absurd 
                else (
                    (* Just need to unwrap the definition of unit_prop *)
                    let c = any clause ensures { mem result cnf' /\ mem l' result } in
                    let ghost no_neg = map (fun c -> remove_lit (negate l) c) cnf in
                    assert { mem c no_neg } ;
                    let c' = any clause ensures { c = remove_lit (negate l) result /\ mem result cnf 
                                                by mem c (map (fun c -> remove_lit (negate l) c) cnf) } in
                    assert { mem l' c' } ;
                    absurd
                ) ;
                absurd
            ) ;
            assert { is_unit l cnf' } ;
            assert { forall l' . mem l' prop -> is_unit l' cnf' } ;
            let (chain, cnf', conflict) = do_bcp cnf' (Cons l prop) (Fset.remove l poss_lits) in
            (* The central postcondition: if there is a way to propagate to an empty clause,
             * then conflict will be true. The <- direction is easy because we have a witness.
             * The other direction needs proof. *)
            if pure { not conflict /\ props_to_conflict cnf } then (
                let ghost chain' = any chain ensures { is_unit_chain cnf result /\ 
                                                    mem Nil (bcp cnf result) } in
                match chain' with
                | Nil -> 
                    (* This is an easy contradiction, because we would have conflict = true 
                     * if the empty clause were already present. *)
                    assert { mem Nil (bcp (unit_prop l cnf) Nil) by mem Nil (unit_prop l cnf) } ; absurd
                | Cons l' ls' -> 
                    if pure { l = l' } then (
                        (* Also straightforward, because we already chose to propagate l,
                         * so we would have gottent conflict = true by induction. *)
                        assert { mem Nil (bcp (unit_prop l cnf) ls') } ;
                        absurd
                    ) ;
                    assert { l <> l' } ;
                    if pure { l = negate l' } then (
                        (* This can't be, because propagating l would have led to empty if
                        * negate l were a unit literal. *)
                        assert { remove_lit (negate l) (Cons (negate l) Nil) = Nil } ;
                        absurd
                    ) ;
                    (* Otherwise we satisfy all the preconditions for lemma prop_preserves_prop,
                     * which means that l' :: ls' is a unit chain for cnf', which will lead to
                     * an empty clause when propagated. *)
                    assert { is_unit_chain (unit_prop l' cnf') ls' } ;
                    absurd
                end 
            ) ;
            (Cons l chain, cnf', conflict)
        end

type rup_info = { rup_clause : clause ; chain : chain }
type rat_info = { rat_clause : clause ; pivot_clause : clause ; pivot_info : rup_info }
type tautology = Rup | Rat
type result = Valid (list tautology) | InvalidEmpty cnf rup_info | InvalidStep cnf rup_info rat_info

predicate rup_failure (cnf : cnf) (info : rup_info) =
    not (rup cnf info.rup_clause) /\
    match info.rup_clause with
    | Nil -> 
        let cnf' = bcp cnf info.chain in
        is_unit_chain cnf info.chain /\ 
        forall chain' . is_unit_chain cnf' chain' -> 
                        forall c . mem c (bcp cnf' chain') <-> mem c cnf'
    | Cons _ _ -> 
        let cnf' = bcp (cnf ++ (negate_clause info.rup_clause)) info.chain in
        is_unit_chain (cnf ++ (negate_clause info.rup_clause)) info.chain /\ 
        forall chain' . is_unit_chain cnf' chain' -> 
                        forall c . mem c (bcp cnf' chain') <-> mem c cnf'
    end

predicate rat_failure (cnf : cnf) (info : rat_info) =
    not (rat cnf info.rat_clause) /\
    match info.rat_clause with
    | Nil -> false
    | Cons l _ ->
        mem info.pivot_clause (pivot_clauses cnf l) /\
        info.pivot_info.rup_clause = resolve info.rat_clause info.pivot_clause l /\
        rup_failure cnf info.pivot_info
    end

predicate proof_failure (cnf : cnf) (result : result) =
    match result with
    | Valid _ -> false
    | InvalidEmpty steps rup_info -> rup_failure (steps ++ cnf) rup_info
    | InvalidStep steps rup_info rat_info -> 
        rup_failure (steps ++ cnf) rup_info /\ rat_failure (steps ++ cnf) rat_info
    end
    
let check_rup (cnf : cnf) (c : clause) : option rup_info =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { not (clause_redundant c) }
    ensures { match result with
              | None -> rup cnf c /\ (c = Nil -> props_to_conflict cnf)
              | Some info -> info.rup_clause = c /\ rup_failure cnf info
              end }
    let cnf' = match c with 
               | Nil -> cnf 
               | Cons _ _ -> 
                    assert { no_trivial_clauses (negate_clause c) } ;
                    cnf ++ (negate_clause c) 
               end
    in
    assert { no_trivial_clauses cnf' } ;
    let ghost lits = cnf_lits cnf' in
    let chain, _, conflict = do_bcp cnf' Nil lits in
    if conflict then (
        match c with
        | Nil ->
            unit_chain_mono cnf chain ;
            unit_prop_mono cnf chain Nil ;
            let ghost nc = Cons {var=0 ; sign=true} (Cons {var=0 ; sign=false} Nil) in
            unit_chain_nomatter (Cons nc cnf) (cnf ++ negate_clause c) chain ;
            bcp_nomatter (Cons nc cnf) (cnf ++ negate_clause c) chain ;
            assert { props_to_conflict (cnf ++ (negate_clause c)) }
        | _ -> assert { props_to_conflict cnf' }
        end ;
        None
    ) else (
        match c with
        | Nil ->
            if pure { exists chain' . is_unit_chain (cnf ++ negate_clause Nil) chain' /\
                                      mem Nil (bcp (cnf ++ negate_clause Nil) chain') } then (
                let chain' = any chain ensures { is_unit_chain (cnf ++ negate_clause Nil) result /\ 
                                                 mem Nil (bcp (cnf ++ negate_clause Nil) result) } in
                let ghost nc = Cons {var=0 ; sign=true} (Cons {var=0 ; sign=false} Nil) in
                unit_chain_nomatter (cnf ++ negate_clause Nil) (Cons nc cnf) chain' ;
                unit_chain_mono' cnf chain' {var=0; sign=true} ;
                bcp_nomatter (cnf ++ negate_clause Nil) (Cons nc cnf) chain' ;
                unit_prop_mono' cnf chain' Nil {var=0; sign=true} ;
                absurd
            ) ;
            assert { not (rup cnf c) }
        | _ -> assert { not (rup cnf c) }
        end ;
        Some { rup_clause = c ; chain = chain }
    )

let check_rat (cnf : cnf) (c : clause) : option rat_info =
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { not (clause_redundant c) /\ not (clause_trivial c) }
    requires { c <> Nil }
    ensures { match result with
              | None -> rat cnf c
              | Some info -> info.rat_clause = c /\ rat_failure cnf info
              end }
    let rec get_pivots (l : lit) (cnf : cnf) : list clause =
        ensures { forall c . mem c result <-> mem c (pivot_clauses cnf l) }
        variant { cnf }
        match cnf with
        | Nil -> Nil
        | Cons c cs -> 
            if do_mem (negate l) c lit_eq 
            then Cons c (get_pivots l cs) 
            else get_pivots l cs
        end
    in
    let do_resolve (c c' : clause) (l : lit) : clause =
        requires { not (clause_redundant c) /\ not (clause_redundant c') }
        requires { mem l c && mem (negate l) c' }
        ensures { result = resolve c c' l }
        remove_redundant_lits ((do_remove_lit l c) ++ (do_remove_lit (negate l) c'))
    in
    let rec check_pivots (l : lit) (ps : list clause) (ghost qs : list clause) : option (clause, rup_info) =
        requires { no_redundant_clauses ps }
        requires { exists cs . c = Cons l cs }
        requires { forall c' . mem c' ps \/ mem c' qs <-> mem c' (pivot_clauses cnf l) }
        requires { forall c' . mem c' qs -> rup cnf (resolve c c' l) }
        ensures { match result with
                  | None -> forall c' . mem c' ps -> rup cnf (resolve c c' l)
                  | Some (c', info) ->
                    not (rat cnf c) /\
                    mem c' (pivot_clauses cnf l) /\
                    info.rup_clause = resolve c c' l /\
                    rup_failure cnf info
                  end }
        variant { ps }
        match ps with
        | Nil -> None
        | Cons p ps' -> 
            assert { mem (negate l) p by mem p (pivot_clauses cnf l) } ;
            match check_rup cnf (do_resolve c p l) with
            | None -> check_pivots l ps' (Cons p qs)
            | Some info -> Some (p, info)
            end
        end
    in
    match c with
    | Nil -> absurd
    | Cons l _ -> 
        match check_pivots l (get_pivots l cnf) Nil with
        | None -> None
        | Some (p, info) -> Some { rat_clause = c ; pivot_clause = p ; pivot_info = info }
        end
    end

let rec check_proof (cnf : cnf) (pf : proof) (steps : cnf) (ts : list tautology) (ghost orig : cnf) : result =
    requires { cnf = steps ++ orig }
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { no_redundant_clauses pf /\ no_trivial_clauses pf }
    ensures { match result with
              | Valid _ -> valid_proof cnf pf
              | _ -> proof_failure orig result
              end }
    variant { pf }
    match pf with
    | Nil -> 
        match check_rup cnf Nil with
        | None -> Valid (Cons Rup ts)
        | Some rup_info -> InvalidEmpty steps rup_info
        end
    | Cons c cs -> 
        match check_rup cnf c with
        | None -> check_proof (Cons c cnf) cs (Cons c steps) (Cons Rup ts) orig
        | Some rup_info ->
            match c with
            | Nil -> InvalidEmpty steps rup_info
            | _ ->
                match check_rat cnf c with
                | None -> check_proof (Cons c cnf) cs (Cons c steps) (Cons Rat ts) orig
                | Some rat_info -> InvalidStep steps rup_info rat_info
                end
            end
        end
    end

let rec check_derivation (cnf : cnf) (pf : proof) (steps : cnf) (ts : list tautology) (ghost orig : cnf) : result =
    requires { cnf = steps ++ orig }
    requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
    requires { no_redundant_clauses pf /\ no_trivial_clauses pf }
    ensures { match result with
              | Valid _ -> valid_derivation cnf pf
              | _ -> proof_failure orig result
              end }
    variant { pf }
    match pf with
    | Nil -> Valid Nil
    | Cons c Nil -> 
        match check_rup cnf c with
        | None -> Valid (Cons Rup ts)
        | Some rup_info -> 
            match c with
            | Nil -> InvalidEmpty steps rup_info
            | _ -> 
                match check_rat cnf c with
                | None -> Valid (Cons Rat ts)
                | Some rat_info -> InvalidStep steps rup_info rat_info
                end
            end
        end
    | Cons c cs -> 
        match check_rup cnf c with
        | None -> check_derivation (Cons c cnf) cs (Cons c steps) (Cons Rup ts) orig
        | Some rup_info ->
            match c with
            | Nil -> InvalidEmpty steps rup_info
            | _ ->
                match check_rat cnf c with
                | None -> check_derivation (Cons c cnf) cs (Cons c steps) (Cons Rat ts) orig
                | Some rat_info -> InvalidStep steps rup_info rat_info
                end
            end
        end
    end

let rec remove_redundant_clauses (cnf : cnf) : cnf =
    ensures { no_redundant_clauses result }
    ensures { no_trivial_clauses result }
    ensures { forall rho . cnf_sat_with rho cnf <-> cnf_sat_with rho result }
    variant { cnf }
    match cnf with
    | Nil -> Nil
    | Cons c cs -> 
        if check_trivial c then remove_redundant_clauses cs
        else ( 
            let c' = remove_redundant_lits c in
            let cs' = remove_redundant_clauses cs in
            let cnf' = Cons c' cs' in
            if pure { exists rho . cnf_sat_with rho cnf /\ not (cnf_sat_with rho cnf') } then (
                let rho = any valuation ensures { cnf_sat_with result cnf /\ not (cnf_sat_with result cnf') } in
                assert { clause_sat_with rho c' } ;
                assert { cnf_sat_with rho cs' } ;
                absurd
            ) ;
            if pure { exists rho . cnf_sat_with rho cnf' /\ not (cnf_sat_with rho cnf) } then (
                let rho = any valuation ensures { cnf_sat_with result cnf' /\ not (cnf_sat_with result cnf) } in
                assert { clause_sat_with rho c } ;
                assert { cnf_sat_with rho cs } ;
                absurd
            ) ;
            cnf'
        )
    end

let rec does_subsume (c c' : clause) =
  ensures { result <-> subsumes c c' }
  variant { c }
  match c with
  | Nil -> true
  | Cons l ls -> do_mem l c' lit_eq && does_subsume ls c'
  end
  
let rec remove_subsumed (c : clause) (cnf : cnf) : cnf =
  ensures { forall c' . mem c' result <-> 
        mem c' cnf /\ not (subsumes c c') }
  variant { cnf }
  match cnf with
  | Nil -> Nil
  | Cons c' cs -> 
    if does_subsume c c' then remove_subsumed c cs
    else Cons c' (remove_subsumed c cs)
  end

let extend_and_simplify (cnf : cnf) (c : clause) : cnf = 
  requires { no_redundant_clauses cnf /\ no_trivial_clauses cnf }
  requires { not (clause_redundant c) /\ not (clause_trivial c) }
  ensures { implied cnf c -> (forall rho . cnf_sat_with rho result <-> cnf_sat_with rho cnf) }
  ensures { rat cnf c -> equisat cnf result }
  let cnf' = remove_subsumed c cnf in
  let cnf'' = Cons c cnf' in
  if pure { implied cnf c } then (
    if pure { exists rho . cnf_sat_with rho cnf'' /\ not (cnf_sat_with rho cnf) } then (
      let rho = any valuation ensures { cnf_sat_with result cnf'' /\ not (cnf_sat_with result cnf) } in
      let c' = any clause ensures { mem result cnf /\ not (clause_sat_with rho result) } in
      assert { not (mem c' cnf'') } ;
      assert { subsumes c c' } ;
      let l = any lit ensures { mem result c /\ Map.get rho result.var = result.sign
                                by clause_sat_with rho c } in
      assert { mem l c' } ;
      absurd
    )
  ) ;
  if pure { rat cnf c } then (
    if pure { (exists rho . cnf_sat_with rho cnf'') /\ not (exists rho . cnf_sat_with rho cnf) } then (
      let rho = any valuation ensures { cnf_sat_with result cnf'' /\ not (cnf_sat_with result cnf) } in
      let c' = any clause ensures { mem result cnf /\ not (clause_sat_with rho result) } in
      assert { not (mem c' cnf'') } ;
      assert { subsumes c c' } ;
      let l = any lit ensures { mem result c /\ Map.get rho result.var = result.sign
                                by clause_sat_with rho c } in
      assert { mem l c' } ;
      absurd
    ) ;
    if pure { not (exists rho . cnf_sat_with rho cnf'') /\ (exists rho . cnf_sat_with rho cnf) } then (
      let rho = any valuation ensures { cnf_sat_with result (Cons c cnf) /\ not (cnf_sat_with result cnf'') 
                                        by equisat cnf (Cons c cnf) } in
      let c' = any clause ensures { mem result cnf'' /\ not (clause_sat_with rho result) } in
      assert { not (mem c' cnf) } ;
      assert { c' = c } ;
      absurd
    )
  ) ;
  let ghost lits = cnf_lits cnf'' in
  let _, cnf, _ = do_bcp cnf'' Nil lits in
  cnf

end