window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "drup", "modulename": "drup", "kind": "module", "doc": "<h1 id=\"a-verified-drup-proof-checker\">A Verified DRUP Proof Checker</h1>\n\n<p>As the title suggests, a verified implementation of a checker for propositional unsatisfiability proofs in the  <a href=\"https://satcompetition.github.io/2022/certificates.html\">DRUP format</a> that is produced by many solvers.\nThe core of the checker is written in <a href=\"https://why3.lri.fr/\">Why3</a>, which is extracted to OCaml, compiled natively, and exported as a C library with Python bindings.</p>\n\n<ul>\n<li>The checker also supports RAT clauses, so DRAT proofs are accepted.</li>\n<li>The current implementation is not optimized, and will be considerably slower than <a href=\"https://github.com/marijnheule/drat-trim\">DRAT-trim</a> on large proofs (see <a href=\"#performance\">performance</a> below).</li>\n<li>Accordingly, the frontend does not accept proofs in binary format.</li>\n</ul>\n\n<p>The verification can be checked by running <code>src/librupchecker/rup_pure.mlw</code> in Why3. \nMost of the verification conditions complete with the <code>Auto level 0</code> tactic, and the rest either with a few levels of splitting followed by <code>Auto 0</code> or <code>Auto 1</code>, or simply with <code>Auto 2</code>.\nIt was developed using Why3 1.5.1, Alt-Ergo 2.4.0, Z3 4.8.6, and CVC4 1.8.\nVerification has not been attempted with earlier versions of Why3 or the provers.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>If you use a recent Linux distribution on x86_64, you should be able to install the compiled wheel from PyPI:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$<span class=\"w\"> </span>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>drup\n</code></pre>\n</div>\n\n<p>Otherwise, you need to have OCaml (&gt;= 4.12), Ctypes (&gt;=0.20), Why3 (&gt;= 1.5.1), and Dune (&gt;=2.9.3) installed.\nThe most straightforward way to install these is to use <a href=\"https://opam.ocaml.org/doc/Install.html\">opam</a>, which is available in most package systems, and then install Why3 and Dune (a sufficiently recent version of OCaml should already be installed with Opam): </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$<span class=\"w\"> </span>opam<span class=\"w\"> </span>install<span class=\"w\"> </span>why3<span class=\"w\"> </span>dune\n</code></pre>\n</div>\n\n<p>If you do not intend to check the verification of the library or develop it further, then you do not need to install Why3's IDE or any of the solvers that it supports.</p>\n\n<p>Once OCaml and Why3 are installed, make sure that Python <code>build</code> is installed:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$<span class=\"w\"> </span>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>build\n</code></pre>\n</div>\n\n<p>Then, clone this repository, build, and install the package:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$<span class=\"w\"> </span>git<span class=\"w\"> </span>clone<span class=\"w\"> </span>https://github.com/cmu-transparency/verified_rup.git\n$<span class=\"w\"> </span><span class=\"nb\">cd</span><span class=\"w\"> </span>verified_rup\n$<span class=\"w\"> </span>python<span class=\"w\"> </span>-m<span class=\"w\"> </span>build\n$<span class=\"w\"> </span>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>dist/*.whl\n</code></pre>\n</div>\n\n<h2 id=\"usage\">Usage</h2>\n\n<h3 id=\"command-line-interface\">Command line interface</h3>\n\n<p>The package provides a command line interface for checking proofs stored in files:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$<span class=\"w\"> </span>drup<span class=\"w\"> </span>--help\nusage:<span class=\"w\"> </span>drup<span class=\"w\"> </span><span class=\"o\">[</span>-h<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>-d<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>-v<span class=\"o\">]</span><span class=\"w\"> </span>dimacs<span class=\"w\"> </span>drup\n\nChecks<span class=\"w\"> </span>DRUP<span class=\"w\"> </span><span class=\"p\">&amp;</span><span class=\"w\"> </span>DRAT<span class=\"w\"> </span>proofs<span class=\"w\"> </span>against<span class=\"w\"> </span>DIMACS<span class=\"w\"> </span>source.<span class=\"w\"> </span>Returns<span class=\"w\"> </span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span>the<span class=\"w\"> </span>proof<span class=\"w\"> </span>is<span class=\"w\"> </span>valid,<span class=\"w\"> </span>-1<span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span>not,<span class=\"w\"> </span>or<span class=\"w\"> </span>a<span class=\"w\"> </span>negative<span class=\"w\"> </span>error<span class=\"w\"> </span>code<span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span>the<span class=\"w\"> </span>input<span class=\"w\"> </span>is<span class=\"w\"> </span>invalid.\n\npositional<span class=\"w\"> </span>arguments:\n<span class=\"w\">  </span>dimacs<span class=\"w\">            </span>Path<span class=\"w\"> </span>to<span class=\"w\"> </span>a<span class=\"w\"> </span>DIMACS<span class=\"w\"> </span>CNF<span class=\"w\"> </span>formula\n<span class=\"w\">  </span>drup<span class=\"w\">              </span>Path<span class=\"w\"> </span>to<span class=\"w\"> </span>a<span class=\"w\"> </span>DRUP/DRAT<span class=\"w\"> </span>proof\n\noptional<span class=\"w\"> </span>arguments:\n<span class=\"w\">  </span>-h,<span class=\"w\"> </span>--help<span class=\"w\">        </span>show<span class=\"w\"> </span>this<span class=\"w\"> </span><span class=\"nb\">help</span><span class=\"w\"> </span>message<span class=\"w\"> </span>and<span class=\"w\"> </span><span class=\"nb\">exit</span>\n<span class=\"w\">  </span>-d,<span class=\"w\"> </span>--derivation<span class=\"w\">  </span>Check<span class=\"w\"> </span>each<span class=\"w\"> </span>step,<span class=\"w\"> </span>ignore<span class=\"w\"> </span>absence<span class=\"w\"> </span>of<span class=\"w\"> </span>empty<span class=\"w\"> </span>clause\n<span class=\"w\">  </span>-v,<span class=\"w\"> </span>--verbose<span class=\"w\">     </span>Print<span class=\"w\"> </span>detailed<span class=\"w\"> </span>information<span class=\"w\"> </span>about<span class=\"w\"> </span>failed<span class=\"w\"> </span>checks\n\nFor<span class=\"w\"> </span>more<span class=\"w\"> </span>information<span class=\"w\"> </span>visit<span class=\"w\"> </span>https://github.com/cmu-transparency/verified_rup\n</code></pre>\n</div>\n\n<h3 id=\"as-a-python-module\">As a Python module</h3>\n\n<p>See the documentation for details of the API.\nThe primary function is <code>drup.check_proof</code>, or alternatively, <code>drup.check_derivation</code> to check each step of the proof, ignoring the absence of an empty clause).</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span> <span class=\"nf\">check_proof</span><span class=\"p\">(</span><span class=\"n\">formula</span> <span class=\"p\">:</span> <span class=\"n\">Cnf</span><span class=\"p\">,</span> <span class=\"n\">proof</span> <span class=\"p\">:</span> <span class=\"n\">Proof</span><span class=\"p\">,</span> <span class=\"n\">verbose</span> <span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">CheckerResult</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"sd\">&quot;&quot;&quot;Check a sequence of RUP and RAT clauses against a CNF. Inputs are Python iterables</span>\n<span class=\"sd\">  of clauses, where each clause is an iterable of signed Python ints.</span>\n\n<span class=\"sd\">  Args:</span>\n<span class=\"sd\">    formula (Cnf): Cnf as an iterable of clauses.</span>\n<span class=\"sd\">    proof (Proof): Iterable of RUP or RAT clauses.</span>\n<span class=\"sd\">    verbose (bool, optional): Return detailed information</span>\n<span class=\"sd\">      if the check fails. Defaults to False.</span>\n\n<span class=\"sd\">  Returns:</span>\n<span class=\"sd\">    CheckerResult: CheckerResult struct representing the result of the check.</span>\n\n<span class=\"sd\">  Raises:</span>\n<span class=\"sd\">    ValueError: If the formula or proof cannot be formatted.</span>\n<span class=\"sd\">  &quot;&quot;&quot;</span>\n</code></pre>\n</div>\n\n<p>This takes a CNF and Proof as an iterable of iterables of signed integers, and returns a <code>CheckerResult</code>.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">class</span> <span class=\"nc\">CheckerResult</span><span class=\"p\">:</span>\n\n<span class=\"w\">  </span><span class=\"sd\">&#39;&#39;&#39;</span>\n<span class=\"sd\">  Result of a proof check.</span>\n\n<span class=\"sd\">  Attributes:</span>\n\n<span class=\"sd\">    outcome (`Outcome`): The outcome of the check. If the check</span>\n<span class=\"sd\">      succeeded, this will be Outcome.VALID. If the check failed,</span>\n<span class=\"sd\">      this will be Outcome.INVALID.</span>\n\n<span class=\"sd\">    steps (`Optional[Cnf]`): Completed proof steps prior to an invalid step, </span>\n<span class=\"sd\">      if the proof was invalid.</span>\n\n<span class=\"sd\">    rup_info (`Optional[RupInfo]`): Information on a failed RUP check,</span>\n<span class=\"sd\">      if the proof was invalid.</span>\n\n<span class=\"sd\">    rat_info (`Optional[RatInfo]`): Information on a failed RAT check,</span>\n<span class=\"sd\">      if the proof was invalid. The RAT clause in this object will</span>\n<span class=\"sd\">      be the same as the RUP clause in `rup_info`.</span>\n<span class=\"sd\">  &#39;&#39;&#39;</span>\n</code></pre>\n</div>\n\n<p>There are corresponding convenience functions <code>check_proof_from_strings</code> and <code>check_proof_from_files</code>, similarly for <code>check_derivation</code>.</p>\n\n<h2 id=\"performance\">Performance</h2>\n\n<p>At present, the implementation of RUP checking is not optimized, and drop lines are ignored.\nUnit propagation does not take advantage of watched literals, and does not use mutable data structures.\nNonetheless, the performance compares well to that of <a href=\"https://github.com/marijnheule/drat-trim\">DRAT-trim</a> on small proofs (&lt;200 variables, a few hundred clauses).</p>\n\n<p>We measure this on random unsatisfiable instances generated by the procedure described in <a href=\"#references\">[1]</a>.\nTo evaluate the performance of DRAT-trim without the overhead of creating and tearing down a new process for each instance, we compiled it into a library with the same <code>check_from_strings</code> interface as the C library, and called it using <a href=\"https://docs.python.org/3/library/ctypes.html\">ctypes</a>.\nIn the table below, each configuration is run on 10,000 instances, with proofs generated by <a href=\"https://www.labri.fr/perso/lsimon/research/glucose/\">Glucose 4</a>.</p>\n\n<table>\n<thead>\n<tr>\n  <th># vars</th>\n  <th># clauses (avg)</th>\n  <th>pf len (avg)</th>\n  <th><code>drup (sec, avg)</code></th>\n  <th><code>drat-trim (sec, avg)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>25</td>\n  <td>147.7</td>\n  <td>7.3</td>\n  <td>0.001</td>\n  <td>0.085</td>\n</tr>\n<tr>\n  <td>50</td>\n  <td>280.5</td>\n  <td>14.2</td>\n  <td>0.006</td>\n  <td>0.179</td>\n</tr>\n<tr>\n  <td>75</td>\n  <td>413.5</td>\n  <td>26.3</td>\n  <td>0.022</td>\n  <td>0.217</td>\n</tr>\n<tr>\n  <td>100</td>\n  <td>548.2</td>\n  <td>40.6</td>\n  <td>0.068</td>\n  <td>0.172</td>\n</tr>\n<tr>\n  <td>150</td>\n  <td>811.8</td>\n  <td>102.7</td>\n  <td>0.407</td>\n  <td>0.326</td>\n</tr>\n<tr>\n  <td>200</td>\n  <td>1079.5</td>\n  <td>227.9</td>\n  <td>1.916</td>\n  <td>0.292</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"references\">References</h3>\n\n<p><a href=\"https://openreview.net/forum?id=HJMC_iA5tm\">[1]</a> Daniel Selsam, Matthew Lamm, Benedikt B\u00fcnz, Percy Liang, Leonardo de Moura, David L. Dill. <em>Learning a SAT Solver from Single-Bit Supervision</em>. International Conference on Learning Representations (ICLR), 2019.</p>\n\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n\n<p>Many thanks to <a href=\"http://www.cs.cmu.edu/~fp/\">Frank Pfenning</a>, <a href=\"https://www.cs.cmu.edu/~jereeves/\">Joseph Reeves</a>, and <a href=\"https://www.cs.cmu.edu/~mheule/\">Marijn Huele</a> for the ongoing insightful discussions that led to this project.</p>\n"}, {"fullname": "drup.Lit", "modulename": "drup", "qualname": "Lit", "kind": "variable", "doc": "<p>A signed integer representing a literal.</p>\n", "default_value": "&lt;class &#x27;int&#x27;&gt;"}, {"fullname": "drup.Clause", "modulename": "drup", "qualname": "Clause", "kind": "variable", "doc": "<p>A sequence of literals.</p>\n", "default_value": "typing.Iterable[int]"}, {"fullname": "drup.Chain", "modulename": "drup", "qualname": "Chain", "kind": "variable", "doc": "<p>A sequence of clauses.</p>\n", "default_value": "typing.Iterable[int]"}, {"fullname": "drup.Cnf", "modulename": "drup", "qualname": "Cnf", "kind": "variable", "doc": "<p>A sequence of literals.</p>\n", "default_value": "typing.Iterable[typing.Iterable[int]]"}, {"fullname": "drup.Proof", "modulename": "drup", "qualname": "Proof", "kind": "variable", "doc": "<p>A sequence of clauses.</p>\n", "default_value": "typing.Iterable[typing.Iterable[int]]"}, {"fullname": "drup.Outcome", "modulename": "drup", "qualname": "Outcome", "kind": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "drup.Outcome.VALID", "modulename": "drup", "qualname": "Outcome.VALID", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Outcome.VALID: 1&gt;"}, {"fullname": "drup.Outcome.INVALID", "modulename": "drup", "qualname": "Outcome.INVALID", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Outcome.INVALID: 2&gt;"}, {"fullname": "drup.RupInfo", "modulename": "drup", "qualname": "RupInfo", "kind": "class", "doc": "<p>Information on a failed RUP check.</p>\n\n<p><strong>Attributes</strong>:</p>\n\n<p>clause (<code>Clause</code>): The clause that failed the RUP check.</p>\n\n<p>chain (<code>Chain</code>): A sequence of unit literals that failed to\n    derive an empty clause via propagation, with no further \n    opportunities to propagate.</p>\n"}, {"fullname": "drup.RupInfo.__init__", "modulename": "drup", "qualname": "RupInfo.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">clause</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">chain</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "drup.RatInfo", "modulename": "drup", "qualname": "RatInfo", "kind": "class", "doc": "<p>Information on a failed RAT check.</p>\n\n<p><strong>Attributes</strong>:\n  clause (<code>Clause</code>): The clause that failed the RAT check.</p>\n\n<p>pivot_clause (<code>Clause</code>): A pivot clause that failed a RUP check.</p>\n\n<p>rup_info (<code>RupInfo</code>): Information on the failed RUP check.</p>\n"}, {"fullname": "drup.RatInfo.__init__", "modulename": "drup", "qualname": "RatInfo.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">clause</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">pivot_clause</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rup_info</span><span class=\"p\">:</span> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">RupInfo</span></span>)</span>"}, {"fullname": "drup.CheckerResult", "modulename": "drup", "qualname": "CheckerResult", "kind": "class", "doc": "<p>Result of a proof check.</p>\n\n<p><strong>Attributes</strong>:</p>\n\n<p>outcome (<code>Outcome</code>): The outcome of the check. If the check\n    succeeded, this will be Outcome.VALID. If the check failed,\n    this will be Outcome.INVALID.</p>\n\n<p>steps (<code>Optional[Cnf]</code>): Completed proof steps prior to an invalid step, \n    if the proof was invalid.</p>\n\n<p>rup_info (<code>Optional[RupInfo]</code>): Information on a failed RUP check,\n    if the proof was invalid.</p>\n\n<p>rat_info (<code>Optional[RatInfo]</code>): Information on a failed RAT check,\n    if the proof was invalid. The RAT clause in this object will\n    be the same as the RUP clause in <code>rup_info</code>.</p>\n"}, {"fullname": "drup.CheckerResult.__init__", "modulename": "drup", "qualname": "CheckerResult.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">outcome</span><span class=\"p\">:</span> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">Outcome</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">rup_info</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">RupInfo</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rat_info</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">RatInfo</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "drup.check_proof", "modulename": "drup", "qualname": "check_proof", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF. Inputs are Python iterables\nof clauses, where each clause is an iterable of signed Python ints.</p>\n\n<p><strong>Args:</strong>\n  formula (<code>Cnf</code>): Cnf as an iterable of clauses.</p>\n\n<p>proof (<code>Proof</code>): Iterable of RUP or RAT clauses.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">proof</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_proof_from_files", "modulename": "drup", "qualname": "check_proof_from_files", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong>\n  formula_file (str): Path to a file containing a CNF in DIMACS format.\n  proof_file (str): Path to a file containing a sequence of RUP or RAT clauses.\n  verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.\n  FileNotFoundError: If the formula or proof file cannot be found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">proof_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_proof_from_strings", "modulename": "drup", "qualname": "check_proof_from_strings", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong>\n  formula (str): Cnf as a string in DIMACS format. The header\n    is ignored if present.\n  proof (str): Sequence of RUP or RAT clauses format.\n  verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">proof</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_derivation", "modulename": "drup", "qualname": "check_derivation", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF. Inputs are Python iterables\nof clauses, where each clause is an iterable of signed Python ints.</p>\n\n<p><strong>Args:</strong>\n  formula (<code>Cnf</code>): Cnf as an iterable of clauses.</p>\n\n<p>derivation (<code>Proof</code>): Iterable of RUP or RAT clauses.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.\n    If each step in the derivation is either RUP or RAT, then the result will\n    be Outcome.VALID. Otherwise, the result will be Outcome.INVALID.\n    The derivation does not need to contain the empty clause.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or derivation cannot be formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">derivation</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_derivation_from_files", "modulename": "drup", "qualname": "check_derivation_from_files", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong></p>\n\n<p>formula_file (str): Path to a file containing a CNF in DIMACS format.</p>\n\n<p>derivation_file (str): Path to a file containing a sequence of RUP or RAT clauses.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.\n    If each step in the derivation is either RUP or RAT, then the result will\n    be Outcome.VALID. Otherwise, the result will be Outcome.INVALID.\n    The derivation does not need to contain the empty clause.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.\n  FileNotFoundError: If the formula or proof file cannot be found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">derivation_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_derivation_from_strings", "modulename": "drup", "qualname": "check_derivation_from_strings", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong>\n  formula (str): Cnf as a string in DIMACS format. The header\n    is ignored if present.</p>\n\n<p>proof (str): Sequence of RUP or RAT clauses format.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.\n    If each step in the derivation is either RUP or RAT, then the result will\n    be Outcome.VALID. Otherwise, the result will be Outcome.INVALID.\n    The derivation does not need to contain the empty clause.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">derivation</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();