window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "drup", "modulename": "drup", "kind": "module", "doc": "<h1 id=\"a-verified-drup-proof-checker\">A Verified DRUP Proof Checker</h1>\n\n<p>As the title suggests, a verified implementation of a checker for propositional unsatisfiability proofs in the  <a href=\"https://satcompetition.github.io/2022/certificates.html\">DRUP format</a> that is produced by many solvers.\nThe core of the checker is written in <a href=\"https://why3.lri.fr/\">Why3</a>, which is extracted to OCaml, compiled natively, and exported as a C library with Python bindings.</p>\n\n<ul>\n<li>The checker also supports RAT clauses, so DRAT proofs are accepted.</li>\n<li>The current implementation is not optimized, and will be considerably slower than <a href=\"https://github.com/marijnheule/drat-trim\">DRAT-trim</a> on large proofs (see <a href=\"#performance\">performance</a> below).</li>\n<li>Accordingly, the frontend does not accept proofs in binary format.</li>\n</ul>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>If you use a recent Linux distribution on x86_64, you should be able to install the compiled wheel from PyPI:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$ pip install drup\n</code></pre>\n</div>\n\n<p>Otherwise, you need to have OCaml (&gt;= 4.12), Ctypes (&gt;=0.20), Why3 (&gt;= 1.5.1), and Dune (&gt;=2.9.3) installed.\nThe most straightforward way to install these is to use <a href=\"https://opam.ocaml.org/doc/Install.html\">opam</a>, which is available in most package systems, and then install Why3 and Dune (a sufficiently recent version of OCaml should already be installed with Opam): </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$ opam install why3 dune\n</code></pre>\n</div>\n\n<p>If you do not intend to check the verification of the library or develop it further, then you do not need to install Why3's IDE or any of the solvers that it supports.</p>\n\n<p>Once OCaml and Why3 are installed, make sure that Python <code>build</code> is installed:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$ pip install build\n</code></pre>\n</div>\n\n<p>Then, clone this repository, build, and install the package:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$ git clone https://github.com/cmu-transparency/verified_rup.git\n$ <span class=\"nb\">cd</span> verified_rup\n$ python -m build\n$ pip install dist/*.whl\n</code></pre>\n</div>\n\n<h2 id=\"usage\">Usage</h2>\n\n<h3 id=\"command-line-interface\">Command line interface</h3>\n\n<p>The package provides a command line interface for checking proofs stored in files:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>$ drup --help\nusage: drup <span class=\"o\">[</span>-h<span class=\"o\">]</span> <span class=\"o\">[</span>-d<span class=\"o\">]</span> <span class=\"o\">[</span>-v<span class=\"o\">]</span> dimacs drup\n\nChecks DRUP <span class=\"p\">&amp;</span> DRAT proofs against DIMACS source. Returns <span class=\"m\">0</span> <span class=\"k\">if</span> the proof is valid, -1 <span class=\"k\">if</span> not, or a negative error code <span class=\"k\">if</span> the input is invalid.\n\npositional arguments:\n  dimacs            Path to a DIMACS CNF formula\n  drup              Path to a DRUP/DRAT proof\n\noptional arguments:\n  -h, --help        show this <span class=\"nb\">help</span> message and <span class=\"nb\">exit</span>\n  -d, --derivation  Check each step, ignore absence of empty clause\n  -v, --verbose     Print detailed information about failed checks\n\nFor more information visit https://github.com/cmu-transparency/verified_rup\n</code></pre>\n</div>\n\n<h3 id=\"as-a-python-module\">As a Python module</h3>\n\n<p>See the <a href=\"http://fairlyaccountable.org/verified_rup/drup.html\">documentation</a> for details of the API.\nThe primary function is <code>drup.check_proof</code>, or alternatively, <code>drup.check_derivation</code> to check each step of the proof, ignoring the absence of an empty clause). There are corresponding convenience functions <code>check_proof_from_strings</code> and <code>check_proof_from_files</code>, similarly for <code>check_derivation</code>.</p>\n\n<p>The following example uses <a href=\"https://massimolauria.net/cnfgen/\">CNFgen</a> to generate a PHP instance,\nand <a href=\"https://pysathq.github.io/\">PySAT</a> to solve it and generate a DRUP proof.\nTo illustrate the verbose output given for failed checks, only the first ten clauses of the proof are checked against the proof.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">drup</span>\n<span class=\"kn\">import</span> <span class=\"nn\">cnfgen</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pysat.formula</span> <span class=\"kn\">import</span> <span class=\"n\">CNF</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pysat.solvers</span> <span class=\"kn\">import</span> <span class=\"n\">Solver</span>\n\n<span class=\"n\">dimacs</span> <span class=\"o\">=</span> <span class=\"n\">cnfgen</span><span class=\"o\">.</span><span class=\"n\">BinaryPigeonholePrinciple</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dimacs</span><span class=\"p\">()</span>\n<span class=\"n\">cnf</span> <span class=\"o\">=</span> <span class=\"n\">CNF</span><span class=\"p\">(</span><span class=\"n\">from_string</span><span class=\"o\">=</span><span class=\"n\">dimacs</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">clauses</span>\n<span class=\"n\">g4</span> <span class=\"o\">=</span> <span class=\"n\">Solver</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;g4&#39;</span><span class=\"p\">,</span> <span class=\"n\">with_proof</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">bootstrap_with</span><span class=\"o\">=</span><span class=\"n\">cnf</span><span class=\"p\">)</span>\n<span class=\"n\">g4</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n<span class=\"n\">proof</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39; &#39;</span><span class=\"p\">)[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span> <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">g4</span><span class=\"o\">.</span><span class=\"n\">get_proof</span><span class=\"p\">()]</span>\n\n<span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">check_proof</span><span class=\"p\">(</span><span class=\"n\">cnf</span><span class=\"p\">[:</span><span class=\"mi\">10</span><span class=\"p\">],</span> <span class=\"n\">proof</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>This gives a <code>CheckerResult</code> object with the following information:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">CheckerResult</span><span class=\"p\">(</span>\n    <span class=\"n\">Outcome</span><span class=\"o\">.</span><span class=\"n\">INVALID</span><span class=\"p\">,</span> \n    <span class=\"p\">[],</span> \n    <span class=\"n\">RupInfo</span><span class=\"p\">([</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]),</span> \n    <span class=\"n\">RatInfo</span><span class=\"p\">(</span>\n        <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">],</span> \n        <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">],</span> \n        <span class=\"n\">RupInfo</span><span class=\"p\">([</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">])</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The <code>RupInfo</code> component relates that RUP verification failed on the first clause of the proof, <code>4 6 7 8 0</code>, after propagating the literals <code>-4, -6, -7, -8, 3, 5</code>, and failing to find more opposites to propagate.\nLikewise, the <code>RatInfo</code> component relates that RAT verification on this clause failed when checking the pivot on clause <code>-4 -3 0</code>.\nThe resolvent of these clauses, <code>6 7 8 -3 0</code>, failed RUP verification after propagating <code>-6 -7 -8 5 3 -4</code>.</p>\n\n<h2 id=\"performance\">Performance</h2>\n\n<p>At present, the implementation of RUP checking is not optimized, and drop lines are ignored.\nUnit propagation does not take advantage of watched literals, and does not use mutable data structures.\nNonetheless, the performance compares well to that of <a href=\"https://github.com/marijnheule/drat-trim\">DRAT-trim</a> on small proofs (&lt;200 variables, a few hundred clauses).</p>\n\n<p>We measure this on random unsatisfiable instances generated by the procedure described in <a href=\"#references\">[1]</a>.\nTo evaluate the performance of DRAT-trim without the overhead of creating and tearing down a new process for each instance, we compiled it into a library with the same <code>check_from_strings</code> interface as the C library, and called it using <a href=\"https://docs.python.org/3/library/ctypes.html\">ctypes</a>.\nIn the table below, each configuration is run on 10,000 instances, with proofs generated by <a href=\"https://www.labri.fr/perso/lsimon/research/glucose/\">Glucose 4</a>.</p>\n\n<table>\n<thead>\n<tr>\n  <th># vars</th>\n  <th># clauses (avg)</th>\n  <th>pf len (avg)</th>\n  <th><code>drup (sec, avg)</code></th>\n  <th><code>drat-trim (sec, avg)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>25</td>\n  <td>147.7</td>\n  <td>7.3</td>\n  <td>0.001</td>\n  <td>0.085</td>\n</tr>\n<tr>\n  <td>50</td>\n  <td>280.5</td>\n  <td>14.2</td>\n  <td>0.006</td>\n  <td>0.179</td>\n</tr>\n<tr>\n  <td>75</td>\n  <td>413.5</td>\n  <td>26.3</td>\n  <td>0.022</td>\n  <td>0.217</td>\n</tr>\n<tr>\n  <td>100</td>\n  <td>548.2</td>\n  <td>40.6</td>\n  <td>0.068</td>\n  <td>0.172</td>\n</tr>\n<tr>\n  <td>150</td>\n  <td>811.8</td>\n  <td>102.7</td>\n  <td>0.407</td>\n  <td>0.326</td>\n</tr>\n<tr>\n  <td>200</td>\n  <td>1079.5</td>\n  <td>227.9</td>\n  <td>1.916</td>\n  <td>0.292</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"references\">References</h3>\n\n<p><a href=\"https://openreview.net/forum?id=HJMC_iA5tm\">[1]</a> Daniel Selsam, Matthew Lamm, Benedikt B\u00fcnz, Percy Liang, Leonardo de Moura, David L. Dill. <em>Learning a SAT Solver from Single-Bit Supervision</em>. International Conference on Learning Representations (ICLR), 2019.</p>\n\n<h2 id=\"verification\">Verification</h2>\n\n<p>The verification can be examined by running <code>src/librupchecker/rup_pure.mlw</code> in Why3, or by checking the Why3 session in <code>src/librupchecker/rup_pure/why3session.xml</code>. \nThe proof was developed using Why3 1.5.1, Alt-Ergo 2.4.0, Z3 4.8.6, and CVC4 1.8.\nVerification has not been attempted with earlier versions of Why3 or the provers.</p>\n\n<p>The primary contract on the proof checker is as follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">requires</span> <span class=\"o\">{</span> <span class=\"n\">no_redundant_clauses</span> <span class=\"n\">cnf</span> <span class=\"o\">/</span><span class=\"err\">\\</span> <span class=\"n\">no_trivial_clauses</span> <span class=\"n\">cnf</span> <span class=\"o\">}</span>\n<span class=\"n\">requires</span> <span class=\"o\">{</span> <span class=\"n\">no_redundant_clauses</span> <span class=\"n\">pf</span> <span class=\"o\">/</span><span class=\"err\">\\</span> <span class=\"n\">no_trivial_clauses</span> <span class=\"n\">pf</span> <span class=\"o\">}</span>\n<span class=\"n\">ensures</span> <span class=\"o\">{</span> <span class=\"k\">match</span> <span class=\"n\">result</span> <span class=\"k\">with</span>\n            <span class=\"o\">|</span> <span class=\"nc\">Valid</span> <span class=\"o\">-&gt;</span> <span class=\"n\">valid_proof</span> <span class=\"n\">cnf</span> <span class=\"n\">pf</span>\n            <span class=\"o\">|</span> <span class=\"o\">_</span> <span class=\"o\">-&gt;</span> <span class=\"n\">proof_failure</span> <span class=\"n\">orig</span> <span class=\"n\">result</span>\n            <span class=\"k\">end</span> <span class=\"o\">}</span>\n</code></pre>\n</div>\n\n<p>The bindings used by this library take care of removing redundant and trivial clauses.\nThe <code>valid_proof</code> predicate is a straightforward translation of DRAT certification requirements.\nA <code>proof_failure</code> result provides additional assurances about the verbose output of the checker.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">predicate</span> <span class=\"n\">proof_failure</span> <span class=\"o\">(</span><span class=\"n\">cnf</span> <span class=\"o\">:</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">result</span> <span class=\"o\">:</span> <span class=\"n\">result</span><span class=\"o\">)</span> <span class=\"o\">=</span>\n    <span class=\"k\">match</span> <span class=\"n\">result</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Valid</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">false</span>\n    <span class=\"o\">|</span> <span class=\"nc\">InvalidEmpty</span> <span class=\"n\">steps</span> <span class=\"n\">rup_info</span> <span class=\"o\">-&gt;</span> <span class=\"n\">rup_failure</span> <span class=\"o\">(</span><span class=\"n\">steps</span> <span class=\"o\">++</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"n\">rup_info</span>\n    <span class=\"o\">|</span> <span class=\"nc\">InvalidStep</span> <span class=\"n\">steps</span> <span class=\"n\">rup_info</span> <span class=\"n\">rat_info</span> <span class=\"o\">-&gt;</span> \n        <span class=\"n\">rup_failure</span> <span class=\"o\">(</span><span class=\"n\">steps</span> <span class=\"o\">++</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"n\">rup_info</span> <span class=\"o\">/</span><span class=\"err\">\\</span> <span class=\"n\">rat_failure</span> <span class=\"o\">(</span><span class=\"n\">steps</span> <span class=\"o\">++</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"n\">rat_info</span>\n    <span class=\"k\">end</span>\n</code></pre>\n</div>\n\n<p>An <code>InvalidEmpty</code> result indicates all of the listed <code>steps</code> are valid, but the empty clause was not derived, as witnessed by the provided <code>rup_info</code>.\nThis is only returned when all of the steps in the proof are valid except an empty clause at the end.\nThe <code>rup_info</code> component ensures that the empty clause is not RUP, and that the unit chain used to conclude this is exhaustive.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">predicate</span> <span class=\"n\">rup_failure</span> <span class=\"o\">(</span><span class=\"n\">cnf</span> <span class=\"o\">:</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">info</span> <span class=\"o\">:</span> <span class=\"n\">rup_info</span><span class=\"o\">)</span> <span class=\"o\">=</span>\n    <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">rup</span> <span class=\"n\">cnf</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rup_clause</span><span class=\"o\">)</span> <span class=\"o\">/</span><span class=\"err\">\\</span>\n    <span class=\"k\">match</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rup_clause</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Nil</span> <span class=\"o\">-&gt;</span> \n        <span class=\"k\">let</span> <span class=\"n\">cnf&#39;</span> <span class=\"o\">=</span> <span class=\"n\">bcp</span> <span class=\"n\">cnf</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">chain</span> <span class=\"k\">in</span>\n        <span class=\"n\">is_unit_chain</span> <span class=\"n\">cnf</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">chain</span> <span class=\"o\">/</span><span class=\"err\">\\</span> \n        <span class=\"n\">forall</span> <span class=\"n\">chain&#39;</span> <span class=\"o\">.</span> <span class=\"n\">is_unit_chain</span> <span class=\"n\">cnf&#39;</span> <span class=\"n\">chain&#39;</span> <span class=\"o\">-&gt;</span> \n                        <span class=\"n\">forall</span> <span class=\"n\">c</span> <span class=\"o\">.</span> <span class=\"n\">mem</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">bcp</span> <span class=\"n\">cnf&#39;</span> <span class=\"n\">chain&#39;</span><span class=\"o\">)</span> <span class=\"o\">&lt;-&gt;</span> <span class=\"n\">mem</span> <span class=\"n\">c</span> <span class=\"n\">cnf&#39;</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Cons</span> <span class=\"o\">_</span> <span class=\"o\">_</span> <span class=\"o\">-&gt;</span> \n        <span class=\"k\">let</span> <span class=\"n\">cnf&#39;</span> <span class=\"o\">=</span> <span class=\"n\">bcp</span> <span class=\"o\">(</span><span class=\"n\">cnf</span> <span class=\"o\">++</span> <span class=\"o\">(</span><span class=\"n\">negate_clause</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rup_clause</span><span class=\"o\">))</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">chain</span> <span class=\"k\">in</span>\n        <span class=\"n\">is_unit_chain</span> <span class=\"o\">(</span><span class=\"n\">cnf</span> <span class=\"o\">++</span> <span class=\"o\">(</span><span class=\"n\">negate_clause</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rup_clause</span><span class=\"o\">))</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">chain</span> <span class=\"o\">/</span><span class=\"err\">\\</span> \n        <span class=\"n\">forall</span> <span class=\"n\">chain&#39;</span> <span class=\"o\">.</span> <span class=\"n\">is_unit_chain</span> <span class=\"n\">cnf&#39;</span> <span class=\"n\">chain&#39;</span> <span class=\"o\">-&gt;</span> \n                        <span class=\"n\">forall</span> <span class=\"n\">c</span> <span class=\"o\">.</span> <span class=\"n\">mem</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">bcp</span> <span class=\"n\">cnf&#39;</span> <span class=\"n\">chain&#39;</span><span class=\"o\">)</span> <span class=\"o\">&lt;-&gt;</span> <span class=\"n\">mem</span> <span class=\"n\">c</span> <span class=\"n\">cnf&#39;</span>\n    <span class=\"k\">end</span>\n</code></pre>\n</div>\n\n<p>An <code>InvalidStep</code> result indicates that the <code>steps</code> are valid up to some non-empty step.\nThe next step in the certificate following <code>steps</code> is invalid, as witnessed by the provided <code>rup_info</code> and <code>rat_info</code>.\nIn addition to the assurances on <code>rup_info</code> described above, <code>rat_info</code> provides that the identified pivot clause is not RUP.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">predicate</span> <span class=\"n\">rat_failure</span> <span class=\"o\">(</span><span class=\"n\">cnf</span> <span class=\"o\">:</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">info</span> <span class=\"o\">:</span> <span class=\"n\">rat_info</span><span class=\"o\">)</span> <span class=\"o\">=</span>\n    <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">rat</span> <span class=\"n\">cnf</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rat_clause</span><span class=\"o\">)</span> <span class=\"o\">/</span><span class=\"err\">\\</span>\n    <span class=\"k\">match</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rat_clause</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Nil</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">false</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Cons</span> <span class=\"n\">l</span> <span class=\"o\">_</span> <span class=\"o\">-&gt;</span>\n        <span class=\"n\">mem</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">pivot_clause</span> <span class=\"o\">(</span><span class=\"n\">pivot_clauses</span> <span class=\"n\">cnf</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">/</span><span class=\"err\">\\</span>\n        <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">pivot_info</span><span class=\"o\">.</span><span class=\"n\">rup_clause</span> <span class=\"o\">=</span> <span class=\"n\">resolve</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">rat_clause</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">pivot_clause</span> <span class=\"n\">l</span> <span class=\"o\">/</span><span class=\"err\">\\</span>\n        <span class=\"n\">rup_failure</span> <span class=\"n\">cnf</span> <span class=\"n\">info</span><span class=\"o\">.</span><span class=\"n\">pivot_info</span>\n    <span class=\"k\">end</span>\n</code></pre>\n</div>\n\n<p>The derivation checker provides a similar contract, but rather than ensuring <code>valid_proof</code> on success, it provides <code>valid_derivation</code>.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">predicate</span> <span class=\"n\">valid_derivation</span> <span class=\"o\">(</span><span class=\"n\">cnf</span> <span class=\"o\">:</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">proof</span><span class=\"o\">)</span> <span class=\"o\">=</span>\n    <span class=\"k\">match</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Nil</span> <span class=\"o\">-&gt;</span> <span class=\"bp\">true</span>\n    <span class=\"o\">|</span> <span class=\"nc\">Cons</span> <span class=\"n\">c</span> <span class=\"n\">cs</span> <span class=\"o\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">rup</span> <span class=\"n\">cnf</span> <span class=\"n\">c</span> <span class=\"err\">\\</span><span class=\"o\">/</span> <span class=\"n\">rat</span> <span class=\"n\">cnf</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">/</span><span class=\"err\">\\</span> <span class=\"n\">valid_derivation</span> <span class=\"o\">(</span><span class=\"nc\">Cons</span> <span class=\"n\">c</span> <span class=\"n\">cnf</span><span class=\"o\">)</span> <span class=\"n\">cs</span>\n    <span class=\"k\">end</span>\n</code></pre>\n</div>\n\n<p>This is the same condition as <code>valid_proof</code>, but in the <code>Nil</code> case, the checker does not require that the empty clause is not RUP.</p>\n\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n\n<p>Many thanks to <a href=\"http://www.cs.cmu.edu/~fp/\">Frank Pfenning</a>, <a href=\"https://www.cs.cmu.edu/~jereeves/\">Joseph Reeves</a>, and <a href=\"https://www.cs.cmu.edu/~mheule/\">Marijn Huele</a> for the ongoing insightful discussions that led to this project.</p>\n"}, {"fullname": "drup.Lit", "modulename": "drup", "qualname": "Lit", "kind": "variable", "doc": "<p>A signed integer representing a literal.</p>\n", "default_value": "&lt;class &#x27;int&#x27;&gt;"}, {"fullname": "drup.Clause", "modulename": "drup", "qualname": "Clause", "kind": "variable", "doc": "<p>A sequence of literals.</p>\n", "default_value": "typing.Iterable[int]"}, {"fullname": "drup.Chain", "modulename": "drup", "qualname": "Chain", "kind": "variable", "doc": "<p>A sequence of clauses.</p>\n", "default_value": "typing.Iterable[int]"}, {"fullname": "drup.Cnf", "modulename": "drup", "qualname": "Cnf", "kind": "variable", "doc": "<p>A sequence of literals.</p>\n", "default_value": "typing.Iterable[typing.Iterable[int]]"}, {"fullname": "drup.Proof", "modulename": "drup", "qualname": "Proof", "kind": "variable", "doc": "<p>A sequence of clauses.</p>\n", "default_value": "typing.Iterable[typing.Iterable[int]]"}, {"fullname": "drup.Outcome", "modulename": "drup", "qualname": "Outcome", "kind": "class", "doc": "<p>An enumeration.</p>\n", "bases": "enum.Enum"}, {"fullname": "drup.Outcome.VALID", "modulename": "drup", "qualname": "Outcome.VALID", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Outcome.VALID: 1&gt;"}, {"fullname": "drup.Outcome.INVALID", "modulename": "drup", "qualname": "Outcome.INVALID", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Outcome.INVALID: 2&gt;"}, {"fullname": "drup.RupInfo", "modulename": "drup", "qualname": "RupInfo", "kind": "class", "doc": "<p>Information on a failed RUP check.</p>\n\n<p><strong>Attributes</strong>:</p>\n\n<p>clause (<code>Clause</code>): The clause that failed the RUP check.</p>\n\n<p>chain (<code>Chain</code>): A sequence of unit literals that failed to\n    derive an empty clause via propagation, with no further \n    opportunities to propagate.</p>\n"}, {"fullname": "drup.RupInfo.__init__", "modulename": "drup", "qualname": "RupInfo.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">clause</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">chain</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "drup.RatInfo", "modulename": "drup", "qualname": "RatInfo", "kind": "class", "doc": "<p>Information on a failed RAT check.</p>\n\n<p><strong>Attributes</strong>:\n  clause (<code>Clause</code>): The clause that failed the RAT check.</p>\n\n<p>pivot_clause (<code>Clause</code>): A pivot clause that failed a RUP check.</p>\n\n<p>rup_info (<code>RupInfo</code>): Information on the failed RUP check.</p>\n"}, {"fullname": "drup.RatInfo.__init__", "modulename": "drup", "qualname": "RatInfo.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">clause</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">pivot_clause</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rup_info</span><span class=\"p\">:</span> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">RupInfo</span></span>)</span>"}, {"fullname": "drup.CheckerResult", "modulename": "drup", "qualname": "CheckerResult", "kind": "class", "doc": "<p>Result of a proof check.</p>\n\n<p><strong>Attributes</strong>:</p>\n\n<p>outcome (<code>Outcome</code>): The outcome of the check. If the check\n    succeeded, this will be Outcome.VALID. If the check failed,\n    this will be Outcome.INVALID.</p>\n\n<p>steps (<code>Optional[Cnf]</code>): Completed proof steps prior to an invalid step, \n    if the proof was invalid.</p>\n\n<p>rup_info (<code>Optional[RupInfo]</code>): Information on a failed RUP check,\n    if the proof was invalid.</p>\n\n<p>rat_info (<code>Optional[RatInfo]</code>): Information on a failed RAT check,\n    if the proof was invalid. The RAT clause in this object will\n    be the same as the RUP clause in <code>rup_info</code>.</p>\n"}, {"fullname": "drup.CheckerResult.__init__", "modulename": "drup", "qualname": "CheckerResult.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">outcome</span><span class=\"p\">:</span> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">Outcome</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">rup_info</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">RupInfo</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rat_info</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">RatInfo</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "drup.check_proof", "modulename": "drup", "qualname": "check_proof", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF. Inputs are Python iterables\nof clauses, where each clause is an iterable of signed Python ints.</p>\n\n<p><strong>Args:</strong>\n  formula (<code>Cnf</code>): Cnf as an iterable of clauses.</p>\n\n<p>proof (<code>Proof</code>): Iterable of RUP or RAT clauses.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">proof</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_proof_from_files", "modulename": "drup", "qualname": "check_proof_from_files", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong>\n  formula_file (str): Path to a file containing a CNF in DIMACS format.\n  proof_file (str): Path to a file containing a sequence of RUP or RAT clauses.\n  verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.\n  FileNotFoundError: If the formula or proof file cannot be found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">proof_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_proof_from_strings", "modulename": "drup", "qualname": "check_proof_from_strings", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong>\n  formula (str): Cnf as a string in DIMACS format. The header\n    is ignored if present.\n  proof (str): Sequence of RUP or RAT clauses format.\n  verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">proof</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_derivation", "modulename": "drup", "qualname": "check_derivation", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF. Inputs are Python iterables\nof clauses, where each clause is an iterable of signed Python ints.</p>\n\n<p><strong>Args:</strong>\n  formula (<code>Cnf</code>): Cnf as an iterable of clauses.</p>\n\n<p>derivation (<code>Proof</code>): Iterable of RUP or RAT clauses.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.\n    If each step in the derivation is either RUP or RAT, then the result will\n    be Outcome.VALID. Otherwise, the result will be Outcome.INVALID.\n    The derivation does not need to contain the empty clause.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or derivation cannot be formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">derivation</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_derivation_from_files", "modulename": "drup", "qualname": "check_derivation_from_files", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong></p>\n\n<p>formula_file (str): Path to a file containing a CNF in DIMACS format.</p>\n\n<p>derivation_file (str): Path to a file containing a sequence of RUP or RAT clauses.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.\n    If each step in the derivation is either RUP or RAT, then the result will\n    be Outcome.VALID. Otherwise, the result will be Outcome.INVALID.\n    The derivation does not need to contain the empty clause.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.\n  FileNotFoundError: If the formula or proof file cannot be found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">derivation_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "drup.check_derivation_from_strings", "modulename": "drup", "qualname": "check_derivation_from_strings", "kind": "function", "doc": "<p>Check a sequence of RUP and RAT clauses against a CNF.</p>\n\n<p><strong>Args:</strong>\n  formula (str): Cnf as a string in DIMACS format. The header\n    is ignored if present.</p>\n\n<p>proof (str): Sequence of RUP or RAT clauses format.</p>\n\n<p>verbose (bool, optional): Return detailed information\n    if the check fails. Defaults to False.</p>\n\n<p><strong>Returns:</strong>\n  <code>CheckerResult</code>: CheckerResult struct representing the result of the check.\n    If each step in the derivation is either RUP or RAT, then the result will\n    be Outcome.VALID. Otherwise, the result will be Outcome.INVALID.\n    The derivation does not need to contain the empty clause.</p>\n\n<p><strong>Raises:</strong>\n  ValueError: If the formula or proof cannot be parsed or formatted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formula</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">derivation</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">drup</span><span class=\"o\">.</span><span class=\"n\">wrappers</span><span class=\"o\">.</span><span class=\"n\">CheckerResult</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();